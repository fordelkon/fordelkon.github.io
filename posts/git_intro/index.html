<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git详解 | DL Kong</title><meta name=keywords content="Git,Python"><meta name=description content='这篇博客主要自底向上地介绍Git命令行，有时甚至会使用一些python代码来对一些Git的功能进行更加详细的分析。我一直认为基础一旦打好，那么一些更高级的用法也可以循序渐进地了解，而且是更加透彻的了解。不是像博主一开始那样以为只要死记硬背git add，git commit,git pull，git clone等常见命令的一些用法就可以了😭（实际上网上大多数教程就是这样教的&mldr;），在这上面走了不少弯路，所以从头开始打地基写作此文留以警示⚠️。

Git仓库（Git Repository）
要学习Git，首先我们要知道我们运行Git命令是对什么对象进行操作的，在Git的相关术语中，我们把这个对象叫做Git仓库（Git Repository），Git仓库实际上就是一个文件夹，在这个文件夹里我们通过.git文件夹（隐藏文件夹）对Git仓库中的工作区中的文件（非隐藏文件夹）内容的改变进行记录，当然并不是所有非隐藏文件夹中文件的改变都会被记录，被.gitingore文件所标识的文件被改变后.git文件夹不会对其进行记录。根据我上面所说，Git操作最隐晦的地方就在于对于.git文件夹中内容的修改来保证对于Git仓库非隐藏文件夹中文件内容修改的记录。
根据上面的描述，我们可以得到一下简略的公式：

$$\mathrm{Git}\ \mathrm{Repository} = \mathrm{.git}\ \mathrm{folder} + \mathrm{worktree}\ \mathrm{folder}\tag{1}$$

更加详尽的来说以python来构建Git仓库类：
class GitRepository (object):
    """A git repository"""

    worktree = None
    gitdir = None

    def __init__(self, path):
        self.worktree = path
        self.gitdir = os.path.join(path, ".git")
.git文件夹内部结构探究
前面我们已经知道了Git操作最隐晦的地方就在于对于.git文件夹中内容的修改来保证对于Git仓库非隐藏文件夹中文件内容修改的记录，那接下来我们就要对此进行脱贫攻坚了。由于.git是隐藏文件夹，所以我们要先对.git文件夹中的文件分布有一定的了解，git init初始化后的.git文件夹中的文件分布如图1所示，此时Git仓库内除了.git文件夹之外一片荒芜。

  


图1：运行git init之后.git文件夹的文件分布结构

然后我们再本地Git仓库中添加可见文件，添加后的结果如图2所示。

  


图2：Git仓库添加文件后的文件分布

将上述所有文件运行git add之后在进行git commit观察.git文件夹中的文件分布，如图3所示。可以看到相较于最初的.git文件，我们在git add和git commit之后文件夹中多出了index文件，log文件夹，objects文件夹中的8个文件以及refs/heads下的main文件，其他的一些变化我们不做考虑。有果导因我们可以知道.git文件夹内部的这些变化中有对于Git仓库非隐藏文件夹文件修改的记录。

  


图3：运行git add和git commit之后.git文件夹的文件分布结构

Git对象（Git Object）
上面的变化究竟是如何实现的呢？要知道Git中的几乎一切都被存储为Git对象！也就是说我们可以通过Git对象进行操作来完成上面的变化。说了这么多，让我们来为Git对象下一个比较官方的定义：Git对象就是在 Git 仓库中的文件，它们的路径由它们的内容决定。
Git对象范性可以借由python来实现：
class GitObject (object):

    def __init__(self, data=None):
        if data != None:
            self.deserialize(data)
        else:
            self.init()

    def serialize(self):
	"""将对象转变为zip文件解压缩后的byte格式"""
        raise Exception("Unimplemented!")

    def deserialize(self, data):
	"""data通常为zip文件解压缩后的byte格式，根据类型解码"""
        raise Exception("Unimplemented!")

    def init(self):
        pass # Just do nothing. This is a reasonable default!
Git对象又细分为以下四种类型：GitBlob（Binary Large Object）对象， GitCommit对象， GitTree对象， GitTag对象，以下分别进行介绍。'><meta name=author content="DL Kong"><link rel=canonical href=https://fordelkon.github.io/posts/git_intro/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.c7a0847263ef81d155d535eb3508757a49b1a3680807f60ed1f64e9d4a686070.css integrity="sha256-x6CEcmPvgdFV1TXrNQh1ekmxo2gIB/YO0fZOnUpoYHA=" rel="preload stylesheet" as=style><link rel=icon href=https://fordelkon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://fordelkon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fordelkon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://fordelkon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://fordelkon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://fordelkon.github.io/posts/git_intro/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><style>@media screen and (min-width:769px){.post-content input[type=checkbox]:checked~label>img{transform:scale(1.6);cursor:zoom-out;position:relative;z-index:999}.post-content img.zoomCheck{transition:transform .15s ease;z-index:999;cursor:zoom-in}}</style><link rel=stylesheet href=/css/extended/xcode.css media="(prefers-color-scheme: light)"><link rel=stylesheet href=/css/extended/monokai.css media="(prefers-color-scheme: dark)"><script async src="https://www.googletagmanager.com/gtag/js?id=G-Q603T56FWT"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Q603T56FWT")}</script><meta property="og:url" content="https://fordelkon.github.io/posts/git_intro/"><meta property="og:site_name" content="DL Kong"><meta property="og:title" content="Git详解"><meta property="og:description" content='这篇博客主要自底向上地介绍Git命令行，有时甚至会使用一些python代码来对一些Git的功能进行更加详细的分析。我一直认为基础一旦打好，那么一些更高级的用法也可以循序渐进地了解，而且是更加透彻的了解。不是像博主一开始那样以为只要死记硬背git add，git commit,git pull，git clone等常见命令的一些用法就可以了😭（实际上网上大多数教程就是这样教的…），在这上面走了不少弯路，所以从头开始打地基写作此文留以警示⚠️。
Git仓库（Git Repository） 要学习Git，首先我们要知道我们运行Git命令是对什么对象进行操作的，在Git的相关术语中，我们把这个对象叫做Git仓库（Git Repository），Git仓库实际上就是一个文件夹，在这个文件夹里我们通过.git文件夹（隐藏文件夹）对Git仓库中的工作区中的文件（非隐藏文件夹）内容的改变进行记录，当然并不是所有非隐藏文件夹中文件的改变都会被记录，被.gitingore文件所标识的文件被改变后.git文件夹不会对其进行记录。根据我上面所说，Git操作最隐晦的地方就在于对于.git文件夹中内容的修改来保证对于Git仓库非隐藏文件夹中文件内容修改的记录。
根据上面的描述，我们可以得到一下简略的公式：
$$\mathrm{Git}\ \mathrm{Repository} = \mathrm{.git}\ \mathrm{folder} + \mathrm{worktree}\ \mathrm{folder}\tag{1}$$ 更加详尽的来说以python来构建Git仓库类：
class GitRepository (object): """A git repository""" worktree = None gitdir = None def __init__(self, path): self.worktree = path self.gitdir = os.path.join(path, ".git") .git文件夹内部结构探究 前面我们已经知道了Git操作最隐晦的地方就在于对于.git文件夹中内容的修改来保证对于Git仓库非隐藏文件夹中文件内容修改的记录，那接下来我们就要对此进行脱贫攻坚了。由于.git是隐藏文件夹，所以我们要先对.git文件夹中的文件分布有一定的了解，git init初始化后的.git文件夹中的文件分布如图1所示，此时Git仓库内除了.git文件夹之外一片荒芜。
图1：运行git init之后.git文件夹的文件分布结构 然后我们再本地Git仓库中添加可见文件，添加后的结果如图2所示。
图2：Git仓库添加文件后的文件分布 将上述所有文件运行git add之后在进行git commit观察.git文件夹中的文件分布，如图3所示。可以看到相较于最初的.git文件，我们在git add和git commit之后文件夹中多出了index文件，log文件夹，objects文件夹中的8个文件以及refs/heads下的main文件，其他的一些变化我们不做考虑。有果导因我们可以知道.git文件夹内部的这些变化中有对于Git仓库非隐藏文件夹文件修改的记录。
图3：运行git add和git commit之后.git文件夹的文件分布结构 Git对象（Git Object） 上面的变化究竟是如何实现的呢？要知道Git中的几乎一切都被存储为Git对象！也就是说我们可以通过Git对象进行操作来完成上面的变化。说了这么多，让我们来为Git对象下一个比较官方的定义：Git对象就是在 Git 仓库中的文件，它们的路径由它们的内容决定。
Git对象范性可以借由python来实现：
class GitObject (object): def __init__(self, data=None): if data != None: self.deserialize(data) else: self.init() def serialize(self): """将对象转变为zip文件解压缩后的byte格式""" raise Exception("Unimplemented!") def deserialize(self, data): """data通常为zip文件解压缩后的byte格式，根据类型解码""" raise Exception("Unimplemented!") def init(self): pass # Just do nothing. This is a reasonable default! Git对象又细分为以下四种类型：GitBlob（Binary Large Object）对象， GitCommit对象， GitTree对象， GitTag对象，以下分别进行介绍。'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-24T23:09:00+09:00"><meta property="article:modified_time" content="2025-08-24T23:09:00+09:00"><meta property="article:tag" content="Git"><meta property="article:tag" content="Python"><meta property="og:image" content="https://fordelkon.github.io/img/git_intro_summary.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://fordelkon.github.io/img/git_intro_summary.png"><meta name=twitter:title content="Git详解"><meta name=twitter:description content='这篇博客主要自底向上地介绍Git命令行，有时甚至会使用一些python代码来对一些Git的功能进行更加详细的分析。我一直认为基础一旦打好，那么一些更高级的用法也可以循序渐进地了解，而且是更加透彻的了解。不是像博主一开始那样以为只要死记硬背git add，git commit,git pull，git clone等常见命令的一些用法就可以了😭（实际上网上大多数教程就是这样教的&mldr;），在这上面走了不少弯路，所以从头开始打地基写作此文留以警示⚠️。

Git仓库（Git Repository）
要学习Git，首先我们要知道我们运行Git命令是对什么对象进行操作的，在Git的相关术语中，我们把这个对象叫做Git仓库（Git Repository），Git仓库实际上就是一个文件夹，在这个文件夹里我们通过.git文件夹（隐藏文件夹）对Git仓库中的工作区中的文件（非隐藏文件夹）内容的改变进行记录，当然并不是所有非隐藏文件夹中文件的改变都会被记录，被.gitingore文件所标识的文件被改变后.git文件夹不会对其进行记录。根据我上面所说，Git操作最隐晦的地方就在于对于.git文件夹中内容的修改来保证对于Git仓库非隐藏文件夹中文件内容修改的记录。
根据上面的描述，我们可以得到一下简略的公式：

$$\mathrm{Git}\ \mathrm{Repository} = \mathrm{.git}\ \mathrm{folder} + \mathrm{worktree}\ \mathrm{folder}\tag{1}$$

更加详尽的来说以python来构建Git仓库类：
class GitRepository (object):
    """A git repository"""

    worktree = None
    gitdir = None

    def __init__(self, path):
        self.worktree = path
        self.gitdir = os.path.join(path, ".git")
.git文件夹内部结构探究
前面我们已经知道了Git操作最隐晦的地方就在于对于.git文件夹中内容的修改来保证对于Git仓库非隐藏文件夹中文件内容修改的记录，那接下来我们就要对此进行脱贫攻坚了。由于.git是隐藏文件夹，所以我们要先对.git文件夹中的文件分布有一定的了解，git init初始化后的.git文件夹中的文件分布如图1所示，此时Git仓库内除了.git文件夹之外一片荒芜。

  


图1：运行git init之后.git文件夹的文件分布结构

然后我们再本地Git仓库中添加可见文件，添加后的结果如图2所示。

  


图2：Git仓库添加文件后的文件分布

将上述所有文件运行git add之后在进行git commit观察.git文件夹中的文件分布，如图3所示。可以看到相较于最初的.git文件，我们在git add和git commit之后文件夹中多出了index文件，log文件夹，objects文件夹中的8个文件以及refs/heads下的main文件，其他的一些变化我们不做考虑。有果导因我们可以知道.git文件夹内部的这些变化中有对于Git仓库非隐藏文件夹文件修改的记录。

  


图3：运行git add和git commit之后.git文件夹的文件分布结构

Git对象（Git Object）
上面的变化究竟是如何实现的呢？要知道Git中的几乎一切都被存储为Git对象！也就是说我们可以通过Git对象进行操作来完成上面的变化。说了这么多，让我们来为Git对象下一个比较官方的定义：Git对象就是在 Git 仓库中的文件，它们的路径由它们的内容决定。
Git对象范性可以借由python来实现：
class GitObject (object):

    def __init__(self, data=None):
        if data != None:
            self.deserialize(data)
        else:
            self.init()

    def serialize(self):
	"""将对象转变为zip文件解压缩后的byte格式"""
        raise Exception("Unimplemented!")

    def deserialize(self, data):
	"""data通常为zip文件解压缩后的byte格式，根据类型解码"""
        raise Exception("Unimplemented!")

    def init(self):
        pass # Just do nothing. This is a reasonable default!
Git对象又细分为以下四种类型：GitBlob（Binary Large Object）对象， GitCommit对象， GitTree对象， GitTag对象，以下分别进行介绍。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fordelkon.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Git详解","item":"https://fordelkon.github.io/posts/git_intro/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git详解","name":"Git详解","description":"这篇博客主要自底向上地介绍Git命令行，有时甚至会使用一些python代码来对一些Git的功能进行更加详细的分析。我一直认为基础一旦打好，那么一些更高级的用法也可以循序渐进地了解，而且是更加透彻的了解。不是像博主一开始那样以为只要死记硬背git add，git commit,git pull，git clone等常见命令的一些用法就可以了😭（实际上网上大多数教程就是这样教的\u0026hellip;），在这上面走了不少弯路，所以从头开始打地基写作此文留以警示⚠️。\nGit仓库（Git Repository） 要学习Git，首先我们要知道我们运行Git命令是对什么对象进行操作的，在Git的相关术语中，我们把这个对象叫做Git仓库（Git Repository），Git仓库实际上就是一个文件夹，在这个文件夹里我们通过.git文件夹（隐藏文件夹）对Git仓库中的工作区中的文件（非隐藏文件夹）内容的改变进行记录，当然并不是所有非隐藏文件夹中文件的改变都会被记录，被.gitingore文件所标识的文件被改变后.git文件夹不会对其进行记录。根据我上面所说，Git操作最隐晦的地方就在于对于.git文件夹中内容的修改来保证对于Git仓库非隐藏文件夹中文件内容修改的记录。\n根据上面的描述，我们可以得到一下简略的公式：\n$$\\mathrm{Git}\\ \\mathrm{Repository} = \\mathrm{.git}\\ \\mathrm{folder} + \\mathrm{worktree}\\ \\mathrm{folder}\\tag{1}$$ 更加详尽的来说以python来构建Git仓库类：\nclass GitRepository (object): \u0026#34;\u0026#34;\u0026#34;A git repository\u0026#34;\u0026#34;\u0026#34; worktree = None gitdir = None def __init__(self, path): self.worktree = path self.gitdir = os.path.join(path, \u0026#34;.git\u0026#34;) .git文件夹内部结构探究 前面我们已经知道了Git操作最隐晦的地方就在于对于.git文件夹中内容的修改来保证对于Git仓库非隐藏文件夹中文件内容修改的记录，那接下来我们就要对此进行脱贫攻坚了。由于.git是隐藏文件夹，所以我们要先对.git文件夹中的文件分布有一定的了解，git init初始化后的.git文件夹中的文件分布如图1所示，此时Git仓库内除了.git文件夹之外一片荒芜。\n图1：运行git init之后.git文件夹的文件分布结构 然后我们再本地Git仓库中添加可见文件，添加后的结果如图2所示。\n图2：Git仓库添加文件后的文件分布 将上述所有文件运行git add之后在进行git commit观察.git文件夹中的文件分布，如图3所示。可以看到相较于最初的.git文件，我们在git add和git commit之后文件夹中多出了index文件，log文件夹，objects文件夹中的8个文件以及refs/heads下的main文件，其他的一些变化我们不做考虑。有果导因我们可以知道.git文件夹内部的这些变化中有对于Git仓库非隐藏文件夹文件修改的记录。\n图3：运行git add和git commit之后.git文件夹的文件分布结构 Git对象（Git Object） 上面的变化究竟是如何实现的呢？要知道Git中的几乎一切都被存储为Git对象！也就是说我们可以通过Git对象进行操作来完成上面的变化。说了这么多，让我们来为Git对象下一个比较官方的定义：Git对象就是在 Git 仓库中的文件，它们的路径由它们的内容决定。\nGit对象范性可以借由python来实现：\nclass GitObject (object): def __init__(self, data=None): if data != None: self.deserialize(data) else: self.init() def serialize(self): \u0026#34;\u0026#34;\u0026#34;将对象转变为zip文件解压缩后的byte格式\u0026#34;\u0026#34;\u0026#34; raise Exception(\u0026#34;Unimplemented!\u0026#34;) def deserialize(self, data): \u0026#34;\u0026#34;\u0026#34;data通常为zip文件解压缩后的byte格式，根据类型解码\u0026#34;\u0026#34;\u0026#34; raise Exception(\u0026#34;Unimplemented!\u0026#34;) def init(self): pass # Just do nothing. This is a reasonable default! Git对象又细分为以下四种类型：GitBlob（Binary Large Object）对象， GitCommit对象， GitTree对象， GitTag对象，以下分别进行介绍。\n","keywords":["Git","Python"],"articleBody":"这篇博客主要自底向上地介绍Git命令行，有时甚至会使用一些python代码来对一些Git的功能进行更加详细的分析。我一直认为基础一旦打好，那么一些更高级的用法也可以循序渐进地了解，而且是更加透彻的了解。不是像博主一开始那样以为只要死记硬背git add，git commit,git pull，git clone等常见命令的一些用法就可以了😭（实际上网上大多数教程就是这样教的…），在这上面走了不少弯路，所以从头开始打地基写作此文留以警示⚠️。\nGit仓库（Git Repository） 要学习Git，首先我们要知道我们运行Git命令是对什么对象进行操作的，在Git的相关术语中，我们把这个对象叫做Git仓库（Git Repository），Git仓库实际上就是一个文件夹，在这个文件夹里我们通过.git文件夹（隐藏文件夹）对Git仓库中的工作区中的文件（非隐藏文件夹）内容的改变进行记录，当然并不是所有非隐藏文件夹中文件的改变都会被记录，被.gitingore文件所标识的文件被改变后.git文件夹不会对其进行记录。根据我上面所说，Git操作最隐晦的地方就在于对于.git文件夹中内容的修改来保证对于Git仓库非隐藏文件夹中文件内容修改的记录。\n根据上面的描述，我们可以得到一下简略的公式：\n$$\\mathrm{Git}\\ \\mathrm{Repository} = \\mathrm{.git}\\ \\mathrm{folder} + \\mathrm{worktree}\\ \\mathrm{folder}\\tag{1}$$ 更加详尽的来说以python来构建Git仓库类：\nclass GitRepository (object): \"\"\"A git repository\"\"\" worktree = None gitdir = None def __init__(self, path): self.worktree = path self.gitdir = os.path.join(path, \".git\") .git文件夹内部结构探究 前面我们已经知道了Git操作最隐晦的地方就在于对于.git文件夹中内容的修改来保证对于Git仓库非隐藏文件夹中文件内容修改的记录，那接下来我们就要对此进行脱贫攻坚了。由于.git是隐藏文件夹，所以我们要先对.git文件夹中的文件分布有一定的了解，git init初始化后的.git文件夹中的文件分布如图1所示，此时Git仓库内除了.git文件夹之外一片荒芜。\n图1：运行git init之后.git文件夹的文件分布结构 然后我们再本地Git仓库中添加可见文件，添加后的结果如图2所示。\n图2：Git仓库添加文件后的文件分布 将上述所有文件运行git add之后在进行git commit观察.git文件夹中的文件分布，如图3所示。可以看到相较于最初的.git文件，我们在git add和git commit之后文件夹中多出了index文件，log文件夹，objects文件夹中的8个文件以及refs/heads下的main文件，其他的一些变化我们不做考虑。有果导因我们可以知道.git文件夹内部的这些变化中有对于Git仓库非隐藏文件夹文件修改的记录。\n图3：运行git add和git commit之后.git文件夹的文件分布结构 Git对象（Git Object） 上面的变化究竟是如何实现的呢？要知道Git中的几乎一切都被存储为Git对象！也就是说我们可以通过Git对象进行操作来完成上面的变化。说了这么多，让我们来为Git对象下一个比较官方的定义：Git对象就是在 Git 仓库中的文件，它们的路径由它们的内容决定。\nGit对象范性可以借由python来实现：\nclass GitObject (object): def __init__(self, data=None): if data != None: self.deserialize(data) else: self.init() def serialize(self): \"\"\"将对象转变为zip文件解压缩后的byte格式\"\"\" raise Exception(\"Unimplemented!\") def deserialize(self, data): \"\"\"data通常为zip文件解压缩后的byte格式，根据类型解码\"\"\" raise Exception(\"Unimplemented!\") def init(self): pass # Just do nothing. This is a reasonable default! Git对象又细分为以下四种类型：GitBlob（Binary Large Object）对象， GitCommit对象， GitTree对象， GitTag对象，以下分别进行介绍。\nGitBlob对象 我们先最直观的看看Git中对于Blob内容的展示，如图4所示：\n图4：运行git cat-file之后对a.txt所对应的类型和类型内容的展示 Blobs 是用户数据：你放入 Git 中的每个文件的内容（如a.txt、b.txt、src/c.txt、src/d.txt中的内容）的字节形式都被存储为一个 blob。这样做使它们很容易操作，因为 blob 没有特定的语法或约束，除了基本的对象存储机制之外，它们只是未指定的数据。\nGitBlob对象的python实现如下：\nclass GitBlob(GitObject): fmt=b'blob' def serialize(self): return self.blobdata def deserialize(self, data): self.blobdata = data GitTree对象 同上，我们先最直观的看看Git中对于树内容的展示，如图5所示：\n图5：运行git cat-file之后对最顶层的树所对应的类型和类型内容的展示 非正式地说，树（tree）描述了Git仓库非隐藏文件夹中的内容，它将 blobs（文件对象）与路径关联起来。树是一个由三个元素组成的元组数组，这些元素包括文件模式、相对于工作树的路径，以及一个 SHA-1 值。一个典型的树的内容如下所示：\nMode SHA-1 Path 100644 06f844865cfc4b68116d2cbf00833b294aae63ec .DS_Store 100644 e12523960bf9941182c801077be75dce699ff37c a.txt 100644 753e270e92068316ec7fa2b6a40e780a4e1d14d7 b.txt 040000 30d66379dddee7068ab4fd3a17cc1ef9555278ac src 模式（Mode）就是文件的模式，路径（Path）是文件的位置。SHA-1 是指向一个 blob 或另一个树对象。如果是 blob，路径表示的是一个文件；如果是树对象，路径表示的是一个目录。\n常见的文件模式有以下几种：\n100644: 普通文件，具有标准的读写权限（普通的文本文件或代码文件）。 100755: 可执行文件，具有执行权限（如脚本或可执行程序）。 040000: 目录（directory）。 120000: 符号链接（symbolic link）。 160000: Git 子模块（submodule）。 而实际上当我们解析树的时候，也就是对.git/objects中树的SHA-1路径所代表的文件进行解压缩后提纯到的树对象内容的字节编码，它们的格式通常如下：\n[mode] space [path] 0x00 [sha-1] （byte格式）\n由于树对应的文件夹中的文件不止一个，有时甚至会有在文件夹中进行文件夹嵌套。因此我们要设计出叶子对应单个文件，树对应由不同文件所组成的文件夹。\n我们可以将叶子对象和树对象按以下python代码来表示：\nclass GitTreeLeaf (object): def __init__(self, mode, path, sha): self.mode = mode # 模式 self.path = path # 文件路径 self.sha = sha # 文件路径索引到的文件内容标准化后所对应的sha-1值 class GitTree(GitObject): fmt=b'tree' def deserialize(self, data): # tree_parse是解析所得到的树对象的字节编码数据 self.items = tree_parse(data) def serialize(self): # tree_serialize将解析后的结果求逆得到树对象的字节编码数据 return tree_serialize(self) def init(self): self.items = list() 由于一个树中有时不单单包含叶子更有可能包含子树，具体情形见上面一棵树的典型情况，tree_parse和tree_serialize函数如下所示：\ndef tree_parse(raw): pos = 0 max = len(raw) ret = list() while pos \u003c max: pos, data = tree_parse_one(raw, pos) ret.append(data) return ret def tree_parse_one(raw, start=0): # [mode] space [path] 0x00 [sha-1] （byte格式） # 查找字节形式空格以确定mode x = raw.find(b' ', start) assert x-start == 5 or x-start==6 # 读取mode mode = raw[start:x] if len(mode) == 5: # 标准到6字节 mode = b\"0\" + mode # 查找字节形式空终止符以确定path y = raw.find(b'\\x00', x) # 读取path path = raw[x+1:y] # 读取sha… # raw[y+1:y+21] 提取的是 20 字节的二进制数据（SHA-1 哈希值）。 raw_sha = int.from_bytes(raw[y+1:y+21], \"big\") # int.from_bytes(raw[y+1:y+21], \"big\")将提取的 20 字节二进制数据转 # 换为一个整数，然后使用 format(raw_sha, \"040x\") 将这个整数转换为 40 # 位的十六进制字符串 。Git中通常使用的sha值时这种形式。比如.DS_Store对应 # 的06f844865cfc4b68116d2cbf00833b294aae63ec sha = format(raw_sha, \"040x\") return y+21, GitTreeLeaf(mode, path.decode(\"utf8\"), sha) def tree_serialize(obj): obj.items.sort(key=tree_leaf_sort_key) ret = b'' for i in obj.items: ret += i.mode ret += b' ' ret += i.path.encode(\"utf8\") ret += b'\\x00' sha = int(i.sha, 16) ret += sha.to_bytes(20, byteorder=\"big\") return ret def tree_leaf_sort_key(leaf): if leaf.mode.startswith(b\"10\"): return leaf.path # 文件 else: return leaf.path + \"/\" # 文件夹 GitCommit对象 同上，我们先最直观的看看Git中对于树内容的展示，如图6所示：\n图6：运行git cat-file之后对最顶层的提交所对应的类型和类型内容的展示 一个提交（Commit）的典型如下所示：\ntree 50306289de5ae719af85eaad3430d785517a11e7 parent 735a65cef921f8e30ae55fdf19b695eb15ea8d45 author fordelkon \u003c27xxx88816@qq.com\u003e 1741406298 +0800 committer fordelkon \u003c27xxx88816@qq.com\u003e 1741406298 +0800 life is short, I use Python 从上面的典型来看，一个提交由以下几部分组成：\n树对象，也就是工作树的内容、文件和目录； 零个、一个或多个父提交； 一个作者身份（姓名和邮箱）以及一个时间戳； 一个提交者身份（姓名和邮箱）以及一个时间戳； 一个提交信息。 从提交的组成来看，我们可以明白已经创建好的提交是不可变的。如果我们更改了作者、父提交或任何一个文件，那么我们实际上最终会创建一个新的、不同的提交对象与改变后的结果绑定。所以每一个提交都与它在整个仓库中的位置及其与最初提交的关系紧密相连。换句话说，一个给定的提交 ID （sha-1）不仅标识了某些文件的内容，还将提交与它的整个历史及整个仓库绑定在一起。也就是说，有了提交，我们的Git的历史记录功能就有了保证！ 一个提交对象的python代码如下所示：\nclass GitCommit(GitObject): fmt=b'commit' def deserialize(self, data): # kvlm_parse是解析所得到的提交对象的字节编码数据 self.kvlm = kvlm_parse(data) def serialize(self): # kvlm_serialize将解析后的结果求逆得到提交对象的字节编码数据 return kvlm_serialize(self.kvlm) def init(self): self.kvlm = dict() 由提交的典型来看，我们可以将提交对象的字节编码数据转换成键值对的字典格式，由于有空格和回车。更形象的表示如下:\n[key1] space [value1] \\n … [keyn] space [valuen] \\n [commit]\n因此，kvlm_parse和kvlm_serialize的python代码如下所示\ndef kvlm_parse(raw, start=0, dct=None): # 如果 dct 为空，初始化一个空字典 if not dct: dct = dict() # 不能在函数参数中直接声明 dct=dict()，否则所有函数调用会共用同一个字典， # 导致每次调用时字典不断增长。 # 这个函数是递归的：它读取一个键/值对，然后调用自身来处理下一个位置。 # 因此我们首先需要知道当前的位置：是在一个关键字，还是已经到了消息部分。 # 查找下一个空格和换行符的位置 spc = raw.find(b' ', start) nl = raw.find(b'\\n', start) # 如果空格出现在换行符之前，说明我们有一个关键字。否则，它是最终的消息部分， # 我们会读取直到文件的末尾。 # 基本情况 # ========= # 如果换行符先出现（或者根本没有空格，这种情况下 find 返回 -1）， # 我们假设遇到了一个空行。空行意味着剩余的数据是消息部分。 # 我们将它存储在字典中，键为 None，然后返回。 if (spc \u003c 0) or (nl \u003c spc): assert nl == start dct[None] = raw[start+1:] # 存储消息部分 return dct # 递归情况 # ============== # 读取一个键值对并递归处理下一个。 key = raw[start:spc] # 查找值的结尾。以空格开头的行表示值的延续行， # 因此我们需要循环，直到找到一个不是以空格开头的换行符。 end = start while True: end = raw.find(b'\\n', end+1) if raw[end+1] != ord(' '): break # 找到一个不以空格开头的换行符 # 获取值，同时删除延续行的前导空格 value = raw[spc+1:end].replace(b'\\n ', b'\\n') # 不要覆盖现有的数据内容 if key in dct: # 如果字典中已有该键，且值为列表，则直接添加新值 if type(dct[key]) == list: dct[key].append(value) else: # 如果已有的值不是列表，创建一个列表来存储多个值 dct[key] = [ dct[key], value ] else: # 如果字典中没有该键，则直接存储键值对 dct[key]=value # 递归处理剩余的部分 return kvlm_parse(raw, start=end+1, dct=dct) def kvlm_serialize(kvlm): ret = b'' # 初始化一个空的字节串用于存储序列化结果 # 输出字段 for k in kvlm.keys(): # 跳过消息体本身（消息存储在字典的 None 键中） if k == None: continue val = kvlm[k] # 将单个值规范化为列表，以便统一处理 if type(val) != list: val = [ val ] # 遍历值列表，处理每个值 for v in val: # 拼接键和值，并确保换行符后面有一个空格（用于表示值的延续行） ret += k + b' ' + (v.replace(b'\\n', b'\\n ')) + b'\\n' # 最后拼接消息体，消息体之前需要一个空行分隔 ret += b'\\n' + kvlm[None] return ret # 返回序列化后的字节串 GitTag对象 标签实际上就是引用（refs）。它们位于 .git/refs/tags/ 目录下。值得注意的是，标签有两种类型：轻量标签和标签对象。\n轻量标签（“Lightweight” tags） 仅仅是指向提交、树对象或 blob 对象的普通引用。\n标签对象（Tag objects） 是指向标签类型对象的普通引用。与轻量标签不同，标签对象包含作者、日期、可选的 PGP 签名以及可选的注释。它们的格式与提交对象相同。\n因此，GitTag的python代码如下所示：\nclass GitTag(GitCommit): fmt = b'tag' 我们已经了解了上面四种Git对象，由Git对象的内容决定路径的性质，可以保证对于非隐藏文件夹中文件内容修改的记录。也就是说，Git仓库非隐藏文件夹中的文件一旦被修改，那么相应的Git对象的路径也会发生改变，将修改后的不同的Git对象的文件标准化后压缩按照改变的路径存储在.git/objects文件夹下，这样可以保证对该改变的记录。那么文件的内容和文件的路径有着明确的映射关系吗？Git给出的答案是对标准化后的文件内容进行 SHA-1哈希后得到文件的路径。如何进行标准化也是我们值得注意的，Git中实现的方案是字节形式类型头+字节形式空格+字节形式大小+字节形式空分离符+对象内容的字节编码。 具体方案如下所示：\n[fmt] space [size] 0x00 [data] (byte格式)\n根据这一标准化的形式我们可以对对象进行读和写操作，所有对象的核心载体是对象内容的字节编码。具体python代码如下：\ndef object_read(repo, sha): \"\"\"Read object sha from Git repository repo. Return a GitObject whose exact type depends on the object.\"\"\" # 由sha1值得到对应路径 path = repo_file(repo, \"objects\", sha[0:2], sha[2:]) if not os.path.isfile(path): return None with open (path, \"rb\") as f: raw = zlib.decompress(f.read()) # 读取对象类型 x = raw.find(b' ') # 0x20 字节形式空格 fmt = raw[0:x] # 字节形式类型头 # 读取有效的对象大小 y = raw.find(b'\\x00', x) # 0x00 字节形式空分离符 size = int(raw[x:y].decode(\"ascii\")) if size != len(raw)-y-1: raise Exception(f\"Malformed object {sha}: bad length\") # 根据对象类型选择生成器 match fmt: case b'commit' : c=GitCommit case b'tree' : c=GitTree case b'tag' : c=GitTag case b'blob' : c=GitBlob case _: raise Exception(f\"Unknown type {fmt.decode(\"ascii\")} for object {sha}\") # 调用生成器返回对象 return c(raw[y+1:]) # raw[y+1:]对象内容的字节编码 def object_write(obj, repo=None): # 对象内容的字节编码 data = obj.serialize() # 添加一些前缀成为标准格式 result = obj.fmt + b' ' + str(len(data)).encode() + b'\\x00' + data # 计算sha1 sha = hashlib.sha1(result).hexdigest() if repo: # 由sha1值得到对应路径 path=repo_file(repo, \"objects\", sha[0:2], sha[2:], mkdir=True) if not os.path.exists(path): with open(path, 'wb') as f: # Compress and write f.write(zlib.compress(result)) return sha 好了，前戏已经准备了这么多，我们可以凭借Git仓库和Git对象来实现最最最重要的Git两连击吗（git add和git commit）？答案当然是……否定的。是的，我们已经拥有了这么多的对象，也有了读取和写入对象的功能，但是一旦我们改变文件（不妨就改变a.txt文件的内容），由前面我们说的主要的三种对象来看，GitBlob元数据会改变，随之而来的GitTree元数据会改变，进而GitCommit元数据也会改变。这个过程不是一挥而就的，所以Git种才会分为git add和git commit两步走。在git add的过程中我们将修改后的文件属性变化提交到暂存区（Staging area），也就是我们图3中的.git/index文件中。然后使用git commit将暂存区中的所有记录的文件统合生成新的GitTree，进而生成新的GitCommit。很明显，我们还需要一个表示暂存区的类型。\n暂存区（Staging area） 暂存区在.git文件夹中的展现形式就是.git/index文件，在一次提交之后，.git/index文件可以看作是该提交的一种副本：它保存了与对应的树相同的路径/Blob（对象）的关联关系。但它还保存了Git仓库中关于文件的额外信息，比如它们的创建/修改时间，因此 git status 通常不需要实际比较文件：它只需要检查文件的修改时间是否与索引文件中存储的时间相同，只有当它们不同时，才会执行实际的比较。类比树对象的表示，.git/index文件中包含许多元素，所以我们的第一个任务是对单个元素进行表示，之后是对整体.git/index文件进行表示。\n单个元素和整体.git/index文件的python表示如下：\nclass GitIndexEntry (object): def __init__(self, ctime=None, mtime=None, dev=None, ino=None, mode_type=None, mode_perms=None, uid=None, gid=None, fsize=None, sha=None, flag_assume_valid=None, flag_stage=None, name=None): # 文件元数据最后更改的时间。格式是一个二元组 # (以秒为单位的时间戳, 纳秒) self.ctime = ctime # 文件数据最后更改的时间。格式是一个二元组 # (以秒为单位的时间戳, 纳秒) self.mtime = mtime # 包含该文件的设备ID self.dev = dev # 文件的inode编号 self.ino = ino # 对象类型，可以是 b1000 (普通文件), b1010 (符号链接), # b1110 (gitlink) self.mode_type = mode_type # 对象的权限，表示为一个整数 self.mode_perms = mode_perms # 文件所有者的用户ID self.uid = uid # 文件所有者的组ID self.gid = gid # 对象的大小，以字节为单位 self.fsize = fsize # 对象的SHA哈希值 self.sha = sha # 标志：假设该对象有效 self.flag_assume_valid = flag_assume_valid # 文件的阶段标志 self.flag_stage = flag_stage # 对象的名称（包括完整路径） self.name = name class GitIndex (object): version = None entries = [] # ext = None # sha = None def __init__(self, version=2, entries=None): if not entries: entries = list() self.version = version self.entries = entries .git/index文件是一个二进制文件，可能是出于性能考虑。尽管如此，它的格式相对简单。文件开始部分是一个头部信息，包含了 DIRC 魔法字节、版本号以及该索引文件中的条目总数。更形象的格式如下：\n[DIRC] [version] [count] [entries]\n所以我们可以定义index_read和index_write函数如下：\ndef index_read(repo): # 获取仓库索引文件的路径 index_file = repo_file(repo, \"index\") # 如果索引文件不存在（例如新仓库），则返回一个空的 GitIndex 实例 if not os.path.exists(index_file): return GitIndex() # 打开索引文件，以二进制方式读取 with open(index_file, 'rb') as f: raw = f.read() # 索引文件的头部包含 12 个字节 header = raw[:12] signature = header[:4] # 检查索引文件的魔法字节，必须为 \"DIRC\"，代表 \"DirCache\" assert signature == b\"DIRC\" # 从头部解析版本号（4-8字节），此处只支持版本 2 version = int.from_bytes(header[4:8], \"big\") assert version == 2, \"wyag 只支持索引文件版本 2\" # 从头部解析索引文件中的条目数量（8-12字节） count = int.from_bytes(header[8:12], \"big\") # 用于存储读取到的索引条目 entries = list() # 索引文件内容部分从第 12 个字节开始 content = raw[12:] idx = 0 # 循环解析每个条目，根据文件头部给出的条目数进行循环 for i in range(0, count): # 解析创建时间（秒数和纳秒数） ctime_s = int.from_bytes(content[idx: idx+4], \"big\") ctime_ns = int.from_bytes(content[idx+4: idx+8], \"big\") # 解析修改时间（秒数和纳秒数） mtime_s = int.from_bytes(content[idx+8: idx+12], \"big\") mtime_ns = int.from_bytes(content[idx+12: idx+16], \"big\") # 解析设备 ID dev = int.from_bytes(content[idx+16: idx+20], \"big\") # 解析 inode 编号 ino = int.from_bytes(content[idx+20: idx+24], \"big\") # 忽略的字段 unused = int.from_bytes(content[idx+24: idx+26], \"big\") assert 0 == unused # 解析文件模式（包括类型和权限） mode = int.from_bytes(content[idx+26: idx+28], \"big\") mode_type = mode \u003e\u003e 12 assert mode_type in [0b1000, 0b1010, 0b1110] # 文件类型必须是常规文件、符号链接或 gitlink mode_perms = mode \u0026 0b0000000111111111 # 解析用户 ID 和组 ID uid = int.from_bytes(content[idx+28: idx+32], \"big\") gid = int.from_bytes(content[idx+32: idx+36], \"big\") # 解析文件大小 fsize = int.from_bytes(content[idx+36: idx+40], \"big\") # 解析 SHA（对象 ID），并格式化为 40 字符的小写十六进制字符串 sha = format(int.from_bytes(content[idx+40: idx+60], \"big\"), \"040x\") # 解析标志位 flags = int.from_bytes(content[idx+60: idx+62], \"big\") # 解析假定有效标志位 flag_assume_valid = (flags \u0026 0b1000000000000000) != 0 # 解析扩展标志位（被忽略） flag_extended = (flags \u0026 0b0100000000000000) != 0 assert not flag_extended # 解析阶段标志位 flag_stage = flags \u0026 0b0011000000000000 # 解析文件名长度（12 位） name_length = flags \u0026 0b0000111111111111 # 读取了 62 个字节，继续处理文件名 idx += 62 # 如果文件名长度小于 0xFFF，则文件名之后有一个空字节终止符 if name_length \u003c 0xFFF: assert content[idx + name_length] == 0x00 raw_name = content[idx:idx+name_length] idx += name_length + 1 else: # 处理文件名长度大于等于 0xFFF 的情况，需要查找空字节终止符 print(f\"注意: 文件名长度为 0x{name_length:X} 字节长。\") null_idx = content.find(b'\\x00', idx + 0xFFF) raw_name = content[idx: null_idx] idx = null_idx + 1 # 将文件名解析为 UTF-8 字符串 name = raw_name.decode(\"utf8\") # 索引文件中的数据以 8 字节对齐，因此需要根据指针对齐调整 idx idx = 8 * ceil(idx / 8) # 将解析出的索引条目添加到列表中 entries.append(GitIndexEntry(ctime=(ctime_s, ctime_ns), mtime=(mtime_s, mtime_ns), dev=dev, ino=ino, mode_type=mode_type, mode_perms=mode_perms, uid=uid, gid=gid, fsize=fsize, sha=sha, flag_assume_valid=flag_assume_valid, flag_stage=flag_stage, name=name)) # 返回包含所有索引条目的 GitIndex 实例 return GitIndex(version=version, entries=entries) def index_write(repo, index): with open(repo_file(repo, \"index\"), \"wb\") as f: # 写入头部信息 # 写入魔术字节 \"DIRC\" 以标识该文件为 Git 索引文件。 f.write(b\"DIRC\") # 写入版本号（固定为 2）。 f.write(index.version.to_bytes(4, \"big\")) # 写入索引条目数量。 f.write(len(index.entries).to_bytes(4, \"big\")) # 写入条目数据 idx = 0 for e in index.entries: # 写入创建时间（秒）和创建时间的纳秒部分。 f.write(e.ctime[0].to_bytes(4, \"big\")) f.write(e.ctime[1].to_bytes(4, \"big\")) # 写入修改时间（秒）和修改时间的纳秒部分。 f.write(e.mtime[0].to_bytes(4, \"big\")) f.write(e.mtime[1].to_bytes(4, \"big\")) # 写入设备号和 inode 号。 f.write(e.dev.to_bytes(4, \"big\")) f.write(e.ino.to_bytes(4, \"big\")) # 写入文件权限模式（类型和权限合并）。 mode = (e.mode_type \u003c\u003c 12) | e.mode_perms f.write(mode.to_bytes(4, \"big\")) # 写入用户 ID 和组 ID。 f.write(e.uid.to_bytes(4, \"big\")) f.write(e.gid.to_bytes(4, \"big\")) # 写入文件大小。 f.write(e.fsize.to_bytes(4, \"big\")) # 写入 SHA-1 对象 ID。 f.write(int(e.sha, 16).to_bytes(20, \"big\")) # 处理标志位 `flag_assume_valid`。 flag_assume_valid = 0x1 \u003c\u003c 15 if e.flag_assume_valid else 0 # 将文件名编码为 UTF-8，并计算长度。 name_bytes = e.name.encode(\"utf8\") bytes_len = len(name_bytes) if bytes_len \u003e= 0xFFF: name_length = 0xFFF # 长度过长时，标记为 0xFFF。 else: name_length = bytes_len # 将 `flag_assume_valid`、`flag_stage` 和名称长度合并到 2 个字节中。 f.write((flag_assume_valid | e.flag_stage | name_length).to_bytes(2, \"big\")) # 写入文件名，并附加一个 0x00 作为结尾。 f.write(name_bytes) f.write((0).to_bytes(1, \"big\")) # 计算当前条目的字节数。 idx += 62 + len(name_bytes) + 1 # 若条目不是 8 字节对齐，则进行填充。 if idx % 8 != 0: pad = 8 - (idx % 8) f.write((0).to_bytes(pad, \"big\")) idx += pad 按照我们前面所说的，git add会根据所修改的文件路径对.git/index文件中的内容进行修改。具体实现方式是从.git/index文件中移除指定路径的条目（不物理删除文件），然后对每个路径，读取文件内容，计算文件的哈希值并获取文件的元数据信息，然后将文件的相关信息添加到.git/index文件中，包括 ctime、mtime、文件权限等，最后将新的索引条目写回索引文件。具体的add函数实现如下：\ndef add(repo, paths, delete=True, skip_missing=False): # 首先调用 rm 函数从索引中移除这些路径的条目，避免重复（不物理删除文件）。 rm(repo, paths, delete=False, skip_missing=True) # 获取工作树的根目录路径（末尾加上路径分隔符） worktree = repo.worktree + os.sep # 将路径转换为 (绝对路径，相对路径) 的对，并确保它们在工作树内且为文件 clean_paths = set() for path in paths: abspath = os.path.abspath(path) # 获取绝对路径 if not (abspath.startswith(worktree) and os.path.isfile(abspath)): # 确保路径在工作树内且为文件 raise Exception(f\"Not a file, or outside the worktree: {paths}\") # 如果路径无效或不在工作树内，抛出异常 relpath = os.path.relpath(abspath, repo.worktree) # 获取相对路径 clean_paths.add((abspath, relpath)) # 添加到 clean_paths 集合中 # 查找并读取索引。由于 `rm` 已经修改了索引，这里再次读取。 # @FIXME：可以通过传递命令来移动索引，而不是反复读写索引。 index = index_read(repo) # 遍历每个路径对，读取文件，生成哈希并更新索引条目 for (abspath, relpath) in clean_paths: with open(abspath, \"rb\") as fd: sha = object_hash(fd, b\"blob\", repo) # 计算文件的 SHA 哈希值 stat = os.stat(abspath) # 获取文件状态 # 获取文件的创建时间和修改时间（秒和纳秒） ctime_s = int(stat.st_ctime) ctime_ns = stat.st_ctime_ns % 10**9 mtime_s = int(stat.st_mtime) mtime_ns = stat.st_mtime_ns % 10**9 # 创建 Git 索引条目对象 entry = GitIndexEntry(ctime=(ctime_s, ctime_ns), mtime=(mtime_s, mtime_ns), dev=stat.st_dev, ino=stat.st_ino, mode_type=0b1000, mode_perms=0o644, uid=stat.st_uid, gid=stat.st_gid, fsize=stat.st_size, sha=sha, flag_assume_valid=False, flag_stage=False, name=relpath) # 将新条目添加到索引条目列表 index.entries.append(entry) # 将更新后的索引写回文件 index_write(repo, index) def rm(repo, paths, delete=True, skip_missing=False): # 查找并读取索引文件 index = index_read(repo) # 获取工作树的根目录路径（末尾加上路径分隔符） worktree = repo.worktree + os.sep # 将输入路径转换为绝对路径，并确保它们位于工作树内 abspaths = set() for path in paths: abspath = os.path.abspath(path) # 获取绝对路径 if abspath.startswith(worktree): # 确保路径在工作树中 abspaths.add(abspath) else: raise Exception(f\"Cannot remove paths outside of worktree: {paths}\") # 如果路径不在工作树内，抛出异常 # 将要保留的索引条目列表，用于更新索引文件 kept_entries = list() # 将要删除的路径列表，用于物理删除文件 remove = list() # 遍历索引条目，删除匹配的路径，保留其余条目 for e in index.entries: full_path = os.path.join(repo.worktree, e.name) # 获取索引条目的完整路径 if full_path in abspaths: # 如果路径在待删除列表中 remove.append(full_path) # 加入待删除列表 abspaths.remove(full_path) # 从待删除路径中移除 else: kept_entries.append(e) # 保留该条目 # 如果有未在索引中找到的路径，且 skip_missing=False，则抛出异常 if len(abspaths) \u003e 0 and not skip_missing: raise Exception(f\"Cannot remove paths not in the index: {abspaths}\") # 物理删除文件系统中的路径 if delete: for path in remove: os.unlink(path) # 删除文件 # 更新索引条目，并将其写回索引文件 index.entries = kept_entries index_write(repo, index) 然后再使用git add之后的.git/index文件生成树对象，最后再借由树对象生成提交对象！！！具体python代码实现如下：\ndef tree_from_index(repo, index): # 初始化一个字典，用于存储目录及其内容，根目录 \"\" 存储一个空列表。 contents = dict() contents[\"\"] = list() # 遍历索引中的每个条目，构建目录结构。 for entry in index.entries: dirname = os.path.dirname(entry.name) # 获取当前条目的目录名 # 遍历目录路径，直到根目录，确保每个目录都被创建 key = dirname while key != \"\": if key not in contents: # 如果该目录尚未在 contents 中，创建一个空列表 contents[key] = list() key = os.path.dirname(key) # 将条目添加到对应目录的内容列表中 contents[dirname].append(entry) # 获取所有目录的路径并按路径长度从长到短排序 sorted_paths = sorted(contents.keys(), key=len, reverse=True) # 初始化树的 SHA-1 哈希（根树的哈希值将会保存在这里） sha = None # 遍历排序后的路径（目录），构建树对象 for path in sorted_paths: tree = GitTree() # 创建一个新的空树对象 # 遍历该目录下的条目，生成树叶并添加到树中 for entry in contents[path]: if isinstance(entry, GitIndexEntry): # 普通的文件条目 # 转换文件的权限模式，Git 使用十六进制表示，树对象需要的是八进制 ASCII 字符串 leaf_mode = f\"{entry.mode_type:02o}{entry.mode_perms:04o}\".encode(\"ascii\") leaf = GitTreeLeaf(mode=leaf_mode, path=os.path.basename(entry.name), sha=entry.sha) else: # 子目录条目（树） leaf = GitTreeLeaf(mode=b\"040000\", path=entry[0], sha=entry[1]) tree.items.append(leaf) # 将叶子添加到树对象中 # 将生成的树对象写入对象存储，并获取其 SHA-1 哈希 sha = object_write(tree, repo) # 将树对象的哈希值添加到其父目录的内容列表中，作为一对 (文件名, SHA) parent = os.path.dirname(path) # 获取父目录路径 base = os.path.basename(path) # 获取当前目录的名称（例如 \"main.go\"） contents[parent].append((base, sha)) # 将父目录与新生成的树的哈希值关联 return sha # 返回根树的 SHA-1 哈希 def commit_create(repo, tree, parent, author, timestamp, message): commit = GitCommit() # 创建一个新的提交对象 # 设置提交对象的树字段为当前提交的树对象的 SHA-1 值 commit.kvlm[b\"tree\"] = tree.encode(\"ascii\") # 如果有父提交，设置父提交字段 if parent: commit.kvlm[b\"parent\"] = parent.encode(\"ascii\") # 清理提交信息，并在末尾加上换行符 message = message.strip() + \"\\n\" # 格式化时区偏移（例如 \"+0200\" 或 \"-0700\"） offset = int(timestamp.astimezone().utcoffset().total_seconds()) # 获取时区偏移（秒） hours = offset // 3600 # 计算小时 minutes = (offset % 3600) // 60 # 计算分钟 tz = \"{}{:02}{:02}\".format(\"+\" if offset \u003e 0 else \"-\", hours, minutes) # 格式化时区字符串 # 将作者信息格式化为 \"Author Name timestamp timezone\" author = author + timestamp.strftime(\" %s \") + tz # 设置提交对象的作者和提交者字段为相同的值 commit.kvlm[b\"author\"] = author.encode(\"utf8\") commit.kvlm[b\"committer\"] = author.encode(\"utf8\") # 设置提交信息字段 commit.kvlm[None] = message.encode(\"utf8\") # 将提交对象写入对象存储，并返回其 SHA-1 哈希 return object_write(commit, repo) Git二连击可视化 已经了解了上面的底层原理后，对Git两连击的的可视化也就十分简单了，详见下图，参考这才是真正的Git——Git内部原理揭秘！： 现在，😮‍💨，所有Git基础的内容的底层原理以及其代码形式差不多就讲解完了。还有一些比较高级的Git内容我们留待后文。\nGit常用命令进阶 我们已经可视化了Git两连击中细节，下面我们可以从高层次的视角（GitCommit）来对Git中的高阶常用命令进行可视化，可视化结果由Learn Git Branch提供。我们经过一系列的git add和git commit以及git checkout之后得到的初始的GitCommit的分布情况如图7所示。\n图7：初始GitCommit分布情况 接下来先介绍的4个命令的联系如图8所示：\n图8：git reset、git checkout、git add和 git commit的联系 git add和git commit 命令我们已经详细介绍过了，下面再简要对对这4个命令进行叙述。\ngit add files 把当前文件放入暂存区域。 git commit -m message 给暂存区域生成快照并提交，而git commit -a -m message自动将所有被跟踪的文件的更改暂存并提交，省略了git add的步骤。 git reset files 用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。 git checkout files 把文件从暂存区域复制到工作目录，用来丢弃本地修改，而git checkout HEAD files 用来将工作目录中指定文件恢复到当前分支最新一次提交时的状态（即 HEAD 指针指向的提交）。这相当于丢弃对这些文件的所有未提交修改，恢复到上一次提交的版本。 git checkout 分支参数 checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。当不指定文件名，而是给出一个（本地）分支时，那么HEAD标识会移动到那个分支（也就是说，我们“切换”到那个分支了），然后暂存区域和工作目录中的内容会和HEAD对应的提交节点一致。新提交节点（下图中的C1）中的所有文件都会被复制（到暂存区域和工作目录中）；只存在于老的提交节点（C5）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。(分支在.git文件夹中对应.git/refs/heads/中的文件，HEAD对应.git文件夹中的HEAD文件，git checkout stable将HEAD文件内容由ref: refs/heads/main改变成ref: refs/heads/stable同时暂存区和工作目录也会发生变化)\n图9：git checkout stable将分支从main转换到stable 被分离的HEAD标识 如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像main~3类似的东西，就得到一个匿名分支，称作detached HEAD（被分离的HEAD标识），暂存区域和工作目录中的内容会和HEAD对应的提交节点一致。\n图10：git checkout main~3将HEAD分离出来 HEAD处于分离状态时，提交操作可以正常进行如图11所示，但是不会更新任何已命名的分支。(你可以认为这是在更新一个匿名分支。)一旦此后你切换到别的分支，比如说main，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了，如图12所示。\n图11：HEAD标识处于分离状态时的提交操作 图12：git checkout main运行后之前提交节点的情况 但是，如果你想保存这个状态，可以用命令git checkout -b name来创建一个新的分支，如图13所示。\n图13：git checkout -b new运行后可以保存提交状态 git reset reset命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。\n如果不给选项，移动HEAD到指定的提交，并且将更改从暂存区移除，但保留在工作目录中（需要git add和git commit）。如果用--hard选项，移动HEAD到指定的提交，并且重置暂存区和工作目录，如果用--soft选项，仅仅移动HEAD到指定的提交，但保留工作区和暂存区的更改（仅需要git commit）。\n图14：现将HEAD指向main分支再运行git reset main~3后的情况 如果没有给出提交点的版本号，那么默认用HEAD。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用--hard选项，工作目录也同样。\ngit merge merge 命令把不同分支合并起来。合并前，索引必须和当前提交相同。如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。 另一种情况是如果当前提交是另一个分支的祖父节点，就导致fast-forward合并。指向只是简单的移动，并生成一个新的提交。\n图14：运行git merge main前的情况 图15：运行git merge main后的情况，快速前进 否则就是一次真正的合并。默认把当前提交(C5 如下所示)和另一个提交(C7)以及他们的共同祖父节点(C2)进行一次三方合并。结果是先保存当前目录和索引，然后和父节点C7一起做一次新提交。\n图16：运行git merge main前的情况 图17：运行git merge main后的情况，正宗融合 git cherry-pick git cherry-pick命令\"复制\"一个提交节点并在当前分支做一次完全一样的新提交，暂存区和工作目录都发生改变。\n图18：运行git cherry-pick C4之前的情况 图19：运行git cherry-pick C4之后的情况，复制C4在当前main分支下做一次完全相同的提交 ### `git rebase` 衍合是合并命令的另一种选择。合并把两个父分支合并进行一次提交，提交历史不是线性的。衍合在当前分支上重演另一个分支的历史，提交历史是线性的。 本质上，这是线性化的自动的 cherry-pick。\n图20：运行git rebase bugFix之前的情况 图21：运行git rebase bugFix之后的情况 Git本地仓库连接并上传远程仓库 使用ssh密钥将本地git和远程GitHub配对 参考https://zhuanlan.zhihu.com/p/138305054\n本地上传远程6步走战略 git init：将文件夹设置为本地仓库，只有这样才可以把本地的文件传入github仓库。 git remote add origin git@github.com:yourusername/yourprojectname.git：将本地仓库与github仓库进行关联。 git pull origin main(or master)：将GitHub上仓库的内容pull到本地仓库，两者保持一致。 git add：需要上传的文件 添加文件到本地库。（再次上传就是3步走战略） git commit -m “information”：提交文件到本地库。（再次上传就是3步走战略） git push origin main(or master)：上传文件。（再次上传就是3步走战略） 参考网站 Write yourself a Git! 这才是真正的Git——Git内部原理揭秘！ Learn Git Branch ","wordCount":"2214","inLanguage":"en","image":"https://fordelkon.github.io/img/git_intro_summary.png","datePublished":"2025-08-24T23:09:00+09:00","dateModified":"2025-08-24T23:09:00+09:00","author":{"@type":"Person","name":"DL Kong"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://fordelkon.github.io/posts/git_intro/"},"publisher":{"@type":"Organization","name":"DL Kong","logo":{"@type":"ImageObject","url":"https://fordelkon.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fordelkon.github.io/ accesskey=h title="DL Kong (Alt + H)"><img src=https://fordelkon.github.io/logo_filled_outlined_6.png alt="Site icon in header" aria-label=logo height=35>DL Kong</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><button id=menu-trigger aria-haspopup=menu aria-label="Menu Button">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><ul class="menu hidden"><li><a href=https://fordelkon.github.io/about/ title=About><span>About</span></a></li><li><a href=https://fordelkon.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://fordelkon.github.io/teaching/ title=Teaching><span>Teaching</span></a></li><li><a href=https://fordelkon.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fordelkon.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://fordelkon.github.io/posts/>Posts</a></div><h1 class=post-title>Git详解</h1><div class=post-meta><span title='2025-08-24 23:09:00 +0900 +0900'>August 8, 24000</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;DL Kong</div></header><div class="toc side left"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#git仓库git-repository>Git仓库（Git Repository）</a></li><li><a href=#git文件夹内部结构探究>.git文件夹内部结构探究</a></li><li><a href=#git对象git-object>Git对象（Git Object）</a><ul><li><a href=#gitblob对象>GitBlob对象</a></li><li><a href=#gittree对象>GitTree对象</a></li><li><a href=#gitcommit对象>GitCommit对象</a></li><li><a href=#gittag对象>GitTag对象</a><ul><li><a href=#轻量标签lightweight-tags>轻量标签（“Lightweight” tags）</a></li><li><a href=#标签对象tag-objects>标签对象（Tag objects）</a></li></ul></li></ul></li><li><a href=#暂存区staging-area>暂存区（Staging area）</a></li><li><a href=#git二连击可视化>Git二连击可视化</a></li><li><a href=#git常用命令进阶>Git常用命令进阶</a><ul><li><a href=#git-checkout><code>git checkout</code></a><ul><li><a href=#分支参数>分支参数</a></li><li><a href=#被分离的head标识>被分离的HEAD标识</a></li></ul></li><li><a href=#git-reset><code>git reset</code></a></li><li><a href=#git-merge><code>git merge</code></a></li><li><a href=#git-cherry-pick><code>git cherry-pick</code></a></li></ul></li><li><a href=#git本地仓库连接并上传远程仓库>Git本地仓库连接并上传远程仓库</a><ul><li><a href=#使用ssh密钥将本地git和远程github配对>使用ssh密钥将本地git和远程GitHub配对</a></li><li><a href=#本地上传远程6步走战略>本地上传远程6步走战略</a></li></ul></li><li><a href=#参考网站>参考网站</a></li></ul></nav></div></details></div><div class=post-content><p>这篇博客主要自底向上地介绍Git命令行，有时甚至会使用一些<code>python</code>代码来对一些Git的功能进行更加详细的分析。我一直认为基础一旦打好，那么一些更高级的用法也可以循序渐进地了解，而且是更加透彻的了解。不是像博主一开始那样以为只要死记硬背<code>git add</code>，<code>git commit</code>,<code>git pull</code>，<code>git clone</code>等常见命令的一些用法就可以了😭（实际上网上大多数教程就是这样教的&mldr;），在这上面走了不少弯路，所以从头开始打地基写作此文留以警示⚠️。</p><h2 id=git仓库git-repository>Git仓库（Git Repository）<a hidden class=anchor aria-hidden=true href=#git仓库git-repository>#</a></h2><p>要学习Git，首先我们要知道我们运行Git命令是对什么对象进行操作的，在Git的相关术语中，我们把这个对象叫做Git仓库（Git Repository），Git仓库实际上就是一个文件夹，在这个文件夹里我们通过.git文件夹（隐藏文件夹）对Git仓库中的工作区中的文件（非隐藏文件夹）内容的改变进行记录，当然并不是所有非隐藏文件夹中文件的改变都会被记录，被.gitingore文件所标识的文件被改变后.git文件夹不会对其进行记录。根据我上面所说，<font color=#c00000>Git操作最隐晦的地方就在于对于.git文件夹中内容的修改来保证对于Git仓库非隐藏文件夹中文件内容修改的记录</font>。</p><p>根据上面的描述，我们可以得到一下简略的公式：</p><div>$$\mathrm{Git}\ \mathrm{Repository} = \mathrm{.git}\ \mathrm{folder} + \mathrm{worktree}\ \mathrm{folder}\tag{1}$$</div><p>更加详尽的来说以<code>python</code>来构建Git仓库类：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>GitRepository</span> <span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;A git repository&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>worktree</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>gitdir</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>path</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>worktree</span> <span class=o>=</span> <span class=n>path</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>gitdir</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=s2>&#34;.git&#34;</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=git文件夹内部结构探究>.git文件夹内部结构探究<a hidden class=anchor aria-hidden=true href=#git文件夹内部结构探究>#</a></h2><p>前面我们已经知道了<font color=#ff0000>Git操作最隐晦的地方就在于对于.git文件夹中内容的修改来保证对于Git仓库非隐藏文件夹中文件内容修改的记录</font>，那接下来我们就要对此进行脱贫攻坚了。由于.git是隐藏文件夹，所以我们要先对.git文件夹中的文件分布有一定的了解，<code>git init</code>初始化后的.git文件夹中的文件分布如图1所示，此时Git仓库内除了.git文件夹之外一片荒芜。</p><center><img src=./img/gitinit.png alt=图片1 width=400></center><center><strong>图1：运行git init之后.git文件夹的文件分布结构</strong></center><p>然后我们再本地Git仓库中添加可见文件，添加后的结果如图2所示。</p><center><img src=./img/add.png alt=图片1 width=400></center><center><strong>图2：Git仓库添加文件后的文件分布</strong></center><p>将上述所有文件运行<code>git add</code>之后在进行<code>git commit</code>观察.git文件夹中的文件分布，如图3所示。可以看到相较于最初的.git文件，我们在<code>git add</code>和<code>git commit</code>之后文件夹中多出了<code>index</code>文件，<code>log</code>文件夹，<code>objects</code>文件夹中的8个文件以及<code>refs/heads</code>下的<code>main</code>文件，其他的一些变化我们不做考虑。<font color=#ff0000>有果导因我们可以知道.git文件夹内部的这些变化中有对于Git仓库非隐藏文件夹文件修改的记录。</font></p><center><img src=./img/gitaddcommit.png alt=图片1 width=400></center><center><strong>图3：运行git add和git commit之后.git文件夹的文件分布结构</strong></center><h2 id=git对象git-object>Git对象（Git Object）<a hidden class=anchor aria-hidden=true href=#git对象git-object>#</a></h2><p>上面的变化究竟是如何实现的呢？要知道Git中的几乎一切都被存储为Git对象！也就是说我们可以通过Git对象进行操作来完成上面的变化。说了这么多，让我们来为Git对象下一个比较官方的定义：<font color=#ff0000>Git对象就是在 Git 仓库中的文件，它们的路径由它们的内容决定。</font></p><p>Git对象范性可以借由<code>python</code>来实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>GitObject</span> <span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>data</span> <span class=o>!=</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>deserialize</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>init</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>serialize</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=s2>&#34;&#34;&#34;将对象转变为zip文件解压缩后的byte格式&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&#34;Unimplemented!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>deserialize</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=s2>&#34;&#34;&#34;data通常为zip文件解压缩后的byte格式，根据类型解码&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&#34;Unimplemented!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>init</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span> <span class=c1># Just do nothing. This is a reasonable default!</span>
</span></span></code></pre></div><p>Git对象又细分为以下四种类型：GitBlob（Binary Large Object）对象， GitCommit对象， GitTree对象， GitTag对象，以下分别进行介绍。</p><h3 id=gitblob对象>GitBlob对象<a hidden class=anchor aria-hidden=true href=#gitblob对象>#</a></h3><p>我们先最直观的看看Git中对于Blob内容的展示，如图4所示：</p><center><img src=./img/blob.png alt=图片1 width=800></center><center><strong>图4：运行git cat-file之后对a.txt所对应的类型和类型内容的展示</strong></center><p>Blobs 是用户数据：你放入 Git 中的每个文件的内容（如a.txt、b.txt、src/c.txt、src/d.txt中的内容）的字节形式都被存储为一个 blob。这样做使它们很容易操作，因为 blob 没有特定的语法或约束，除了基本的对象存储机制之外，它们只是未指定的数据。</p><p>GitBlob对象的<code>python</code>实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>GitBlob</span><span class=p>(</span><span class=n>GitObject</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>fmt</span><span class=o>=</span><span class=sa>b</span><span class=s1>&#39;blob&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>serialize</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>blobdata</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>deserialize</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>blobdata</span> <span class=o>=</span> <span class=n>data</span>
</span></span></code></pre></div><h3 id=gittree对象>GitTree对象<a hidden class=anchor aria-hidden=true href=#gittree对象>#</a></h3><p>同上，我们先最直观的看看Git中对于树内容的展示，如图5所示：</p><center><img src=./img/tree.png alt=图片1 width=600></center><center><strong>图5：运行git cat-file之后对最顶层的树所对应的类型和类型内容的展示</strong></center><p>非正式地说，树（tree）描述了Git仓库非隐藏文件夹中的内容，它将 blobs（文件对象）与路径关联起来。树是一个由三个元素组成的元组数组，这些元素包括文件模式、相对于工作树的路径，以及一个 SHA-1 值。一个典型的树的内容如下所示：</p><table><thead><tr><th>Mode</th><th>SHA-1</th><th>Path</th></tr></thead><tbody><tr><td>100644</td><td>06f844865cfc4b68116d2cbf00833b294aae63ec</td><td>.DS_Store</td></tr><tr><td>100644</td><td>e12523960bf9941182c801077be75dce699ff37c</td><td>a.txt</td></tr><tr><td>100644</td><td>753e270e92068316ec7fa2b6a40e780a4e1d14d7</td><td>b.txt</td></tr><tr><td>040000</td><td>30d66379dddee7068ab4fd3a17cc1ef9555278ac</td><td>src</td></tr></tbody></table><p>模式（Mode）就是文件的模式，路径（Path）是文件的位置。SHA-1 是指向一个 blob 或另一个树对象。如果是 blob，路径表示的是一个文件；如果是树对象，路径表示的是一个目录。</p><p>常见的文件模式有以下几种：</p><ul><li><strong>100644</strong>: 普通文件，具有标准的读写权限（普通的文本文件或代码文件）。</li><li><strong>100755</strong>: 可执行文件，具有执行权限（如脚本或可执行程序）。</li><li><strong>040000</strong>: 目录（directory）。</li><li><strong>120000</strong>: 符号链接（symbolic link）。</li><li><strong>160000</strong>: Git 子模块（submodule）。</li></ul><p>而实际上当我们解析树的时候，也就是对<code>.git/objects</code>中树的SHA-1路径所代表的文件进行解压缩后提纯到的树对象内容的字节编码，它们的格式通常如下：</p><blockquote><p>[mode] space [path] 0x00 [sha-1] （byte格式）</p></blockquote><p>由于树对应的文件夹中的文件不止一个，有时甚至会有在文件夹中进行文件夹嵌套。因此我们要设计出叶子对应单个文件，树对应由不同文件所组成的文件夹。</p><p>我们可以将叶子对象和树对象按以下<code>python</code>代码来表示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>GitTreeLeaf</span> <span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>mode</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=n>sha</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>mode</span> <span class=o>=</span> <span class=n>mode</span> <span class=c1># 模式</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>path</span> <span class=o>=</span> <span class=n>path</span> <span class=c1># 文件路径</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>sha</span> <span class=o>=</span> <span class=n>sha</span> <span class=c1># 文件路径索引到的文件内容标准化后所对应的sha-1值</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>GitTree</span><span class=p>(</span><span class=n>GitObject</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>fmt</span><span class=o>=</span><span class=sa>b</span><span class=s1>&#39;tree&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>deserialize</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	    <span class=c1># tree_parse是解析所得到的树对象的字节编码数据</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>items</span> <span class=o>=</span> <span class=n>tree_parse</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>serialize</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	    <span class=c1># tree_serialize将解析后的结果求逆得到树对象的字节编码数据</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>tree_serialize</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>init</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>items</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span></code></pre></div><p>由于一个树中有时不单单包含叶子更有可能包含子树，具体情形见上面一棵树的典型情况，<code>tree_parse</code>和<code>tree_serialize</code>函数如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>tree_parse</span><span class=p>(</span><span class=n>raw</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>pos</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nb>max</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>raw</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>pos</span> <span class=o>&lt;</span> <span class=nb>max</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>pos</span><span class=p>,</span> <span class=n>data</span> <span class=o>=</span> <span class=n>tree_parse_one</span><span class=p>(</span><span class=n>raw</span><span class=p>,</span> <span class=n>pos</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>tree_parse_one</span><span class=p>(</span><span class=n>raw</span><span class=p>,</span> <span class=n>start</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=c1># [mode] space [path] 0x00 [sha-1] （byte格式）</span>
</span></span><span class=line><span class=cl>    <span class=c1># 查找字节形式空格以确定mode</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>raw</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39; &#39;</span><span class=p>,</span> <span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>assert</span> <span class=n>x</span><span class=o>-</span><span class=n>start</span> <span class=o>==</span> <span class=mi>5</span> <span class=ow>or</span> <span class=n>x</span><span class=o>-</span><span class=n>start</span><span class=o>==</span><span class=mi>6</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 读取mode</span>
</span></span><span class=line><span class=cl>    <span class=n>mode</span> <span class=o>=</span> <span class=n>raw</span><span class=p>[</span><span class=n>start</span><span class=p>:</span><span class=n>x</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>mode</span><span class=p>)</span> <span class=o>==</span> <span class=mi>5</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 标准到6字节</span>
</span></span><span class=line><span class=cl>        <span class=n>mode</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;0&#34;</span> <span class=o>+</span> <span class=n>mode</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 查找字节形式空终止符以确定path</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=n>raw</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 读取path</span>
</span></span><span class=line><span class=cl>    <span class=n>path</span> <span class=o>=</span> <span class=n>raw</span><span class=p>[</span><span class=n>x</span><span class=o>+</span><span class=mi>1</span><span class=p>:</span><span class=n>y</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 读取sha…</span>
</span></span><span class=line><span class=cl>    <span class=c1># raw[y+1:y+21] 提取的是 20 字节的二进制数据（SHA-1 哈希值）。</span>
</span></span><span class=line><span class=cl>    <span class=n>raw_sha</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>raw</span><span class=p>[</span><span class=n>y</span><span class=o>+</span><span class=mi>1</span><span class=p>:</span><span class=n>y</span><span class=o>+</span><span class=mi>21</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># int.from_bytes(raw[y+1:y+21], &#34;big&#34;)将提取的 20 字节二进制数据转</span>
</span></span><span class=line><span class=cl>    <span class=c1># 换为一个整数，然后使用 format(raw_sha, &#34;040x&#34;) 将这个整数转换为 40 </span>
</span></span><span class=line><span class=cl>    <span class=c1># 位的十六进制字符串 。Git中通常使用的sha值时这种形式。比如.DS_Store对应</span>
</span></span><span class=line><span class=cl>    <span class=c1># 的06f844865cfc4b68116d2cbf00833b294aae63ec</span>
</span></span><span class=line><span class=cl>    <span class=n>sha</span> <span class=o>=</span> <span class=nb>format</span><span class=p>(</span><span class=n>raw_sha</span><span class=p>,</span> <span class=s2>&#34;040x&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>y</span><span class=o>+</span><span class=mi>21</span><span class=p>,</span> <span class=n>GitTreeLeaf</span><span class=p>(</span><span class=n>mode</span><span class=p>,</span> <span class=n>path</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s2>&#34;utf8&#34;</span><span class=p>),</span> <span class=n>sha</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>tree_serialize</span><span class=p>(</span><span class=n>obj</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>obj</span><span class=o>.</span><span class=n>items</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=n>tree_leaf_sort_key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>obj</span><span class=o>.</span><span class=n>items</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>+=</span> <span class=n>i</span><span class=o>.</span><span class=n>mode</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>+=</span> <span class=sa>b</span><span class=s1>&#39; &#39;</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>+=</span> <span class=n>i</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s2>&#34;utf8&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>+=</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>        <span class=n>sha</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>i</span><span class=o>.</span><span class=n>sha</span><span class=p>,</span> <span class=mi>16</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>+=</span> <span class=n>sha</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>20</span><span class=p>,</span> <span class=n>byteorder</span><span class=o>=</span><span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>tree_leaf_sort_key</span><span class=p>(</span><span class=n>leaf</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>leaf</span><span class=o>.</span><span class=n>mode</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;10&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>leaf</span><span class=o>.</span><span class=n>path</span> <span class=c1># 文件</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>leaf</span><span class=o>.</span><span class=n>path</span> <span class=o>+</span> <span class=s2>&#34;/&#34;</span> <span class=c1># 文件夹</span>
</span></span></code></pre></div><h3 id=gitcommit对象>GitCommit对象<a hidden class=anchor aria-hidden=true href=#gitcommit对象>#</a></h3><p>同上，我们先最直观的看看Git中对于树内容的展示，如图6所示：</p><center><img src=./img/commit.png alt=图片1 width=600></center><center><strong>图6：运行git cat-file之后对最顶层的提交所对应的类型和类型内容的展示</strong></center><p>一个提交（Commit）的典型如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>tree 50306289de5ae719af85eaad3430d785517a11e7
</span></span><span class=line><span class=cl>parent 735a65cef921f8e30ae55fdf19b695eb15ea8d45
</span></span><span class=line><span class=cl>author fordelkon &lt;27xxx88816@qq.com&gt; 1741406298 +0800
</span></span><span class=line><span class=cl>committer fordelkon &lt;27xxx88816@qq.com&gt; 1741406298 +0800
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>life is short, I use Python
</span></span></code></pre></div><p>从上面的典型来看，一个提交由以下几部分组成：</p><ul><li>树对象，也就是工作树的内容、文件和目录；</li><li>零个、一个或多个父提交；</li><li>一个作者身份（姓名和邮箱）以及一个时间戳；</li><li>一个提交者身份（姓名和邮箱）以及一个时间戳；</li><li>一个提交信息。
从提交的组成来看，我们可以明白已经创建好的提交是不可变的。如果我们更改了作者、父提交或任何一个文件，那么我们实际上最终会创建一个新的、不同的提交对象与改变后的结果绑定。所以每一个提交都与它在整个仓库中的位置及其与最初提交的关系紧密相连。换句话说，一个给定的提交 ID （sha-1）不仅标识了某些文件的内容，还将提交与它的整个历史及整个仓库绑定在一起。也就是说，有了提交，我们的Git的历史记录功能就有了保证！</li></ul><p>一个提交对象的<code>python</code>代码如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>GitCommit</span><span class=p>(</span><span class=n>GitObject</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>fmt</span><span class=o>=</span><span class=sa>b</span><span class=s1>&#39;commit&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>deserialize</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=c1># kvlm_parse是解析所得到的提交对象的字节编码数据</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>kvlm</span> <span class=o>=</span> <span class=n>kvlm_parse</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>serialize</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=c1># kvlm_serialize将解析后的结果求逆得到提交对象的字节编码数据</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>kvlm_serialize</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>kvlm</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>init</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>kvlm</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span></code></pre></div><p>由提交的典型来看，我们可以将提交对象的字节编码数据转换成键值对的字典格式，由于有空格和回车。更形象的表示如下:</p><blockquote><p>[key1] space [value1] \n &mldr; [keyn] space [valuen] \n [commit]</p></blockquote><p>因此，<code>kvlm_parse</code>和<code>kvlm_serialize</code>的python代码如下所示</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>kvlm_parse</span><span class=p>(</span><span class=n>raw</span><span class=p>,</span> <span class=n>start</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>dct</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 如果 dct 为空，初始化一个空字典</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>dct</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>dct</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># 不能在函数参数中直接声明 dct=dict()，否则所有函数调用会共用同一个字典，</span>
</span></span><span class=line><span class=cl>        <span class=c1># 导致每次调用时字典不断增长。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 这个函数是递归的：它读取一个键/值对，然后调用自身来处理下一个位置。</span>
</span></span><span class=line><span class=cl>    <span class=c1># 因此我们首先需要知道当前的位置：是在一个关键字，还是已经到了消息部分。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 查找下一个空格和换行符的位置</span>
</span></span><span class=line><span class=cl>    <span class=n>spc</span> <span class=o>=</span> <span class=n>raw</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39; &#39;</span><span class=p>,</span> <span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>nl</span> <span class=o>=</span> <span class=n>raw</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 如果空格出现在换行符之前，说明我们有一个关键字。否则，它是最终的消息部分，</span>
</span></span><span class=line><span class=cl>    <span class=c1># 我们会读取直到文件的末尾。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 基本情况</span>
</span></span><span class=line><span class=cl>    <span class=c1># =========</span>
</span></span><span class=line><span class=cl>    <span class=c1># 如果换行符先出现（或者根本没有空格，这种情况下 find 返回 -1），</span>
</span></span><span class=line><span class=cl>    <span class=c1># 我们假设遇到了一个空行。空行意味着剩余的数据是消息部分。</span>
</span></span><span class=line><span class=cl>    <span class=c1># 我们将它存储在字典中，键为 None，然后返回。</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>spc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=ow>or</span> <span class=p>(</span><span class=n>nl</span> <span class=o>&lt;</span> <span class=n>spc</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>assert</span> <span class=n>nl</span> <span class=o>==</span> <span class=n>start</span>
</span></span><span class=line><span class=cl>        <span class=n>dct</span><span class=p>[</span><span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=n>raw</span><span class=p>[</span><span class=n>start</span><span class=o>+</span><span class=mi>1</span><span class=p>:]</span>  <span class=c1># 存储消息部分</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dct</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 递归情况</span>
</span></span><span class=line><span class=cl>    <span class=c1># ==============</span>
</span></span><span class=line><span class=cl>    <span class=c1># 读取一个键值对并递归处理下一个。</span>
</span></span><span class=line><span class=cl>    <span class=n>key</span> <span class=o>=</span> <span class=n>raw</span><span class=p>[</span><span class=n>start</span><span class=p>:</span><span class=n>spc</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 查找值的结尾。以空格开头的行表示值的延续行，</span>
</span></span><span class=line><span class=cl>    <span class=c1># 因此我们需要循环，直到找到一个不是以空格开头的换行符。</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span> <span class=o>=</span> <span class=n>start</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>end</span> <span class=o>=</span> <span class=n>raw</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>end</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>raw</span><span class=p>[</span><span class=n>end</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>!=</span> <span class=nb>ord</span><span class=p>(</span><span class=s1>&#39; &#39;</span><span class=p>):</span> <span class=k>break</span>  <span class=c1># 找到一个不以空格开头的换行符</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 获取值，同时删除延续行的前导空格</span>
</span></span><span class=line><span class=cl>    <span class=n>value</span> <span class=o>=</span> <span class=n>raw</span><span class=p>[</span><span class=n>spc</span><span class=o>+</span><span class=mi>1</span><span class=p>:</span><span class=n>end</span><span class=p>]</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1> &#39;</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 不要覆盖现有的数据内容</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>key</span> <span class=ow>in</span> <span class=n>dct</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 如果字典中已有该键，且值为列表，则直接添加新值</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>dct</span><span class=p>[</span><span class=n>key</span><span class=p>])</span> <span class=o>==</span> <span class=nb>list</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>dct</span><span class=p>[</span><span class=n>key</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 如果已有的值不是列表，创建一个列表来存储多个值</span>
</span></span><span class=line><span class=cl>            <span class=n>dct</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span> <span class=n>dct</span><span class=p>[</span><span class=n>key</span><span class=p>],</span> <span class=n>value</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 如果字典中没有该键，则直接存储键值对</span>
</span></span><span class=line><span class=cl>        <span class=n>dct</span><span class=p>[</span><span class=n>key</span><span class=p>]</span><span class=o>=</span><span class=n>value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 递归处理剩余的部分</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>kvlm_parse</span><span class=p>(</span><span class=n>raw</span><span class=p>,</span> <span class=n>start</span><span class=o>=</span><span class=n>end</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>dct</span><span class=o>=</span><span class=n>dct</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>kvlm_serialize</span><span class=p>(</span><span class=n>kvlm</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;&#39;</span>  <span class=c1># 初始化一个空的字节串用于存储序列化结果</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 输出字段</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=n>kvlm</span><span class=o>.</span><span class=n>keys</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=c1># 跳过消息体本身（消息存储在字典的 None 键中）</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>k</span> <span class=o>==</span> <span class=kc>None</span><span class=p>:</span> <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=n>val</span> <span class=o>=</span> <span class=n>kvlm</span><span class=p>[</span><span class=n>k</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=c1># 将单个值规范化为列表，以便统一处理</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>val</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>list</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>val</span> <span class=o>=</span> <span class=p>[</span> <span class=n>val</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 遍历值列表，处理每个值</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>val</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 拼接键和值，并确保换行符后面有一个空格（用于表示值的延续行）</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>+=</span> <span class=n>k</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39; &#39;</span> <span class=o>+</span> <span class=p>(</span><span class=n>v</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1> &#39;</span><span class=p>))</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 最后拼接消息体，消息体之前需要一个空行分隔</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>+=</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span> <span class=o>+</span> <span class=n>kvlm</span><span class=p>[</span><span class=kc>None</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span>  <span class=c1># 返回序列化后的字节串</span>
</span></span></code></pre></div><h3 id=gittag对象>GitTag对象<a hidden class=anchor aria-hidden=true href=#gittag对象>#</a></h3><p>标签实际上就是引用（refs）。它们位于 .git/refs/tags/ 目录下。值得注意的是，标签有两种类型：轻量标签和标签对象。</p><h4 id=轻量标签lightweight-tags>轻量标签（“Lightweight” tags）<a hidden class=anchor aria-hidden=true href=#轻量标签lightweight-tags>#</a></h4><p>仅仅是指向提交、树对象或 blob 对象的普通引用。</p><h4 id=标签对象tag-objects>标签对象（Tag objects）<a hidden class=anchor aria-hidden=true href=#标签对象tag-objects>#</a></h4><p>是指向标签类型对象的普通引用。与轻量标签不同，标签对象包含作者、日期、可选的 PGP 签名以及可选的注释。它们的格式与提交对象相同。</p><p>因此，GitTag的<code>python</code>代码如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>GitTag</span><span class=p>(</span><span class=n>GitCommit</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>fmt</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;tag&#39;</span>
</span></span></code></pre></div><p>我们已经了解了上面四种Git对象，由Git对象的内容决定路径的性质，可以保证对于非隐藏文件夹中文件内容修改的记录。也就是说，Git仓库非隐藏文件夹中的文件一旦被修改，那么相应的Git对象的路径也会发生改变，将修改后的不同的Git对象的文件标准化后压缩按照改变的路径存储在<code>.git/objects</code>文件夹下，这样可以保证对该改变的记录。那么文件的内容和文件的路径有着明确的映射关系吗？Git给出的答案是对标准化后的文件内容进行 <a href=https://en.wikipedia.org/wiki/SHA-1>SHA-1</a><a href=https://en.wikipedia.org/wiki/Cryptographic_hash_function>哈希</a>后得到文件的路径。如何进行标准化也是我们值得注意的，Git中实现的方案是<font color=#ff0000>字节形式类型头+字节形式空格+字节形式大小+字节形式空分离符+对象内容的字节编码。</font> 具体方案如下所示：</p><blockquote><p>[fmt] space [size] 0x00 [data] (byte格式)</p></blockquote><p>根据这一标准化的形式我们可以对对象进行读和写操作，所有对象的核心载体是对象内容的字节编码。具体<code>python</code>代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>object_read</span><span class=p>(</span><span class=n>repo</span><span class=p>,</span> <span class=n>sha</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Read object sha from Git repository repo.  Return a
</span></span></span><span class=line><span class=cl><span class=s2>    GitObject whose exact type depends on the object.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>    <span class=c1># 由sha1值得到对应路径</span>
</span></span><span class=line><span class=cl>    <span class=n>path</span> <span class=o>=</span> <span class=n>repo_file</span><span class=p>(</span><span class=n>repo</span><span class=p>,</span> <span class=s2>&#34;objects&#34;</span><span class=p>,</span> <span class=n>sha</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=mi>2</span><span class=p>],</span> <span class=n>sha</span><span class=p>[</span><span class=mi>2</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>isfile</span><span class=p>(</span><span class=n>path</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=nb>open</span> <span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=s2>&#34;rb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>raw</span> <span class=o>=</span> <span class=n>zlib</span><span class=o>.</span><span class=n>decompress</span><span class=p>(</span><span class=n>f</span><span class=o>.</span><span class=n>read</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 读取对象类型</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span> <span class=o>=</span> <span class=n>raw</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39; &#39;</span><span class=p>)</span> <span class=c1># 0x20 字节形式空格</span>
</span></span><span class=line><span class=cl>        <span class=n>fmt</span> <span class=o>=</span> <span class=n>raw</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=n>x</span><span class=p>]</span> <span class=c1># 字节形式类型头</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 读取有效的对象大小</span>
</span></span><span class=line><span class=cl>        <span class=n>y</span> <span class=o>=</span> <span class=n>raw</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span> <span class=c1># 0x00 字节形式空分离符</span>
</span></span><span class=line><span class=cl>        <span class=n>size</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>raw</span><span class=p>[</span><span class=n>x</span><span class=p>:</span><span class=n>y</span><span class=p>]</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s2>&#34;ascii&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>size</span> <span class=o>!=</span> <span class=nb>len</span><span class=p>(</span><span class=n>raw</span><span class=p>)</span><span class=o>-</span><span class=n>y</span><span class=o>-</span><span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Malformed object </span><span class=si>{</span><span class=n>sha</span><span class=si>}</span><span class=s2>: bad length&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 根据对象类型选择生成器</span>
</span></span><span class=line><span class=cl>        <span class=k>match</span> <span class=n>fmt</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=sa>b</span><span class=s1>&#39;commit&#39;</span> <span class=p>:</span> <span class=n>c</span><span class=o>=</span><span class=n>GitCommit</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=sa>b</span><span class=s1>&#39;tree&#39;</span>   <span class=p>:</span> <span class=n>c</span><span class=o>=</span><span class=n>GitTree</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=sa>b</span><span class=s1>&#39;tag&#39;</span>    <span class=p>:</span> <span class=n>c</span><span class=o>=</span><span class=n>GitTag</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=sa>b</span><span class=s1>&#39;blob&#39;</span>   <span class=p>:</span> <span class=n>c</span><span class=o>=</span><span class=n>GitBlob</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=n>_</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Unknown type </span><span class=si>{</span><span class=n>fmt</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s2>&#34;ascii&#34;</span><span class=p>)</span><span class=si>}</span><span class=s2> for object </span><span class=si>{</span><span class=n>sha</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 调用生成器返回对象</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>c</span><span class=p>(</span><span class=n>raw</span><span class=p>[</span><span class=n>y</span><span class=o>+</span><span class=mi>1</span><span class=p>:])</span> <span class=c1># raw[y+1:]对象内容的字节编码</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>object_write</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>repo</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 对象内容的字节编码</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=o>=</span> <span class=n>obj</span><span class=o>.</span><span class=n>serialize</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># 添加一些前缀成为标准格式</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>obj</span><span class=o>.</span><span class=n>fmt</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39; &#39;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>data</span><span class=p>))</span><span class=o>.</span><span class=n>encode</span><span class=p>()</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span> <span class=o>+</span> <span class=n>data</span>
</span></span><span class=line><span class=cl>    <span class=c1># 计算sha1</span>
</span></span><span class=line><span class=cl>    <span class=n>sha</span> <span class=o>=</span> <span class=n>hashlib</span><span class=o>.</span><span class=n>sha1</span><span class=p>(</span><span class=n>result</span><span class=p>)</span><span class=o>.</span><span class=n>hexdigest</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>repo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 由sha1值得到对应路径</span>
</span></span><span class=line><span class=cl>        <span class=n>path</span><span class=o>=</span><span class=n>repo_file</span><span class=p>(</span><span class=n>repo</span><span class=p>,</span> <span class=s2>&#34;objects&#34;</span><span class=p>,</span> <span class=n>sha</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=mi>2</span><span class=p>],</span> <span class=n>sha</span><span class=p>[</span><span class=mi>2</span><span class=p>:],</span> <span class=n>mkdir</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>exists</span><span class=p>(</span><span class=n>path</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=s1>&#39;wb&#39;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># Compress and write</span>
</span></span><span class=line><span class=cl>                <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>zlib</span><span class=o>.</span><span class=n>compress</span><span class=p>(</span><span class=n>result</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sha</span>
</span></span></code></pre></div><p>好了，前戏已经准备了这么多，我们可以凭借Git仓库和Git对象来实现最最最重要的Git两连击吗（<code>git add</code>和<code>git commit</code>）？答案当然是&mldr;&mldr;否定的。是的，我们已经拥有了这么多的对象，也有了读取和写入对象的功能，但是一旦我们改变文件（不妨就改变a.txt文件的内容），由前面我们说的主要的三种对象来看，GitBlob元数据会改变，随之而来的GitTree元数据会改变，进而GitCommit元数据也会改变。这个过程不是一挥而就的，所以Git种才会分为<code>git add</code>和<code>git commit</code>两步走。在<code>git add</code>的过程中我们将修改后的文件属性变化提交到暂存区（Staging area），也就是我们图3中的<code>.git/index</code>文件中。然后使用<code>git commit</code>将暂存区中的所有记录的文件统合生成新的GitTree，进而生成新的GitCommit。很明显，我们还需要一个表示暂存区的类型。</p><h2 id=暂存区staging-area>暂存区（Staging area）<a hidden class=anchor aria-hidden=true href=#暂存区staging-area>#</a></h2><p>暂存区在.git文件夹中的展现形式就是<code>.git/index</code>文件，在一次提交之后，<code>.git/index</code>文件可以看作是该提交的一种副本：它保存了与对应的树相同的路径/Blob（对象）的关联关系。但它还保存了Git仓库中关于文件的额外信息，比如它们的创建/修改时间，因此 <code>git status</code> 通常不需要实际比较文件：它只需要检查文件的修改时间是否与索引文件中存储的时间相同，只有当它们不同时，才会执行实际的比较。类比树对象的表示，<code>.git/index</code>文件中包含许多元素，所以我们的第一个任务是对单个元素进行表示，之后是对整体<code>.git/index</code>文件进行表示。</p><p>单个元素和整体<code>.git/index</code>文件的<code>python</code>表示如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>GitIndexEntry</span> <span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>ctime</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>mtime</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>dev</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>ino</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>mode_type</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>mode_perms</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>uid</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>gid</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>fsize</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>sha</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>flag_assume_valid</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>flag_stage</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>name</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 文件元数据最后更改的时间。格式是一个二元组</span>
</span></span><span class=line><span class=cl>        <span class=c1># (以秒为单位的时间戳, 纳秒)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>ctime</span> <span class=o>=</span> <span class=n>ctime</span>
</span></span><span class=line><span class=cl>        <span class=c1># 文件数据最后更改的时间。格式是一个二元组</span>
</span></span><span class=line><span class=cl>        <span class=c1># (以秒为单位的时间戳, 纳秒)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>mtime</span> <span class=o>=</span> <span class=n>mtime</span>
</span></span><span class=line><span class=cl>        <span class=c1># 包含该文件的设备ID</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>dev</span> <span class=o>=</span> <span class=n>dev</span>
</span></span><span class=line><span class=cl>        <span class=c1># 文件的inode编号</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>ino</span> <span class=o>=</span> <span class=n>ino</span>
</span></span><span class=line><span class=cl>        <span class=c1># 对象类型，可以是 b1000 (普通文件), b1010 (符号链接),</span>
</span></span><span class=line><span class=cl>        <span class=c1># b1110 (gitlink)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>mode_type</span> <span class=o>=</span> <span class=n>mode_type</span>
</span></span><span class=line><span class=cl>        <span class=c1># 对象的权限，表示为一个整数</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>mode_perms</span> <span class=o>=</span> <span class=n>mode_perms</span>
</span></span><span class=line><span class=cl>        <span class=c1># 文件所有者的用户ID</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>uid</span> <span class=o>=</span> <span class=n>uid</span>
</span></span><span class=line><span class=cl>        <span class=c1># 文件所有者的组ID</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>gid</span> <span class=o>=</span> <span class=n>gid</span>
</span></span><span class=line><span class=cl>        <span class=c1># 对象的大小，以字节为单位</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>fsize</span> <span class=o>=</span> <span class=n>fsize</span>
</span></span><span class=line><span class=cl>        <span class=c1># 对象的SHA哈希值</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>sha</span> <span class=o>=</span> <span class=n>sha</span>
</span></span><span class=line><span class=cl>        <span class=c1># 标志：假设该对象有效</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>flag_assume_valid</span> <span class=o>=</span> <span class=n>flag_assume_valid</span>
</span></span><span class=line><span class=cl>        <span class=c1># 文件的阶段标志</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>flag_stage</span> <span class=o>=</span> <span class=n>flag_stage</span>
</span></span><span class=line><span class=cl>        <span class=c1># 对象的名称（包括完整路径）</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>GitIndex</span> <span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>version</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>entries</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=c1># ext = None</span>
</span></span><span class=line><span class=cl>    <span class=c1># sha = None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>version</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>entries</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>entries</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>entries</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>version</span> <span class=o>=</span> <span class=n>version</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>entries</span> <span class=o>=</span> <span class=n>entries</span>
</span></span></code></pre></div><p><code>.git/index</code>文件是一个二进制文件，可能是出于性能考虑。尽管如此，它的格式相对简单。文件开始部分是一个头部信息，包含了 DIRC 魔法字节、版本号以及该索引文件中的条目总数。更形象的格式如下：</p><blockquote><p>[DIRC] [version] [count] [entries]</p></blockquote><p>所以我们可以定义<code>index_read</code>和<code>index_write</code>函数如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>index_read</span><span class=p>(</span><span class=n>repo</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 获取仓库索引文件的路径</span>
</span></span><span class=line><span class=cl>    <span class=n>index_file</span> <span class=o>=</span> <span class=n>repo_file</span><span class=p>(</span><span class=n>repo</span><span class=p>,</span> <span class=s2>&#34;index&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 如果索引文件不存在（例如新仓库），则返回一个空的 GitIndex 实例</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>exists</span><span class=p>(</span><span class=n>index_file</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>GitIndex</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 打开索引文件，以二进制方式读取</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>index_file</span><span class=p>,</span> <span class=s1>&#39;rb&#39;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>raw</span> <span class=o>=</span> <span class=n>f</span><span class=o>.</span><span class=n>read</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 索引文件的头部包含 12 个字节</span>
</span></span><span class=line><span class=cl>    <span class=n>header</span> <span class=o>=</span> <span class=n>raw</span><span class=p>[:</span><span class=mi>12</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>signature</span> <span class=o>=</span> <span class=n>header</span><span class=p>[:</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=c1># 检查索引文件的魔法字节，必须为 &#34;DIRC&#34;，代表 &#34;DirCache&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>assert</span> <span class=n>signature</span> <span class=o>==</span> <span class=sa>b</span><span class=s2>&#34;DIRC&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 从头部解析版本号（4-8字节），此处只支持版本 2</span>
</span></span><span class=line><span class=cl>    <span class=n>version</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>header</span><span class=p>[</span><span class=mi>4</span><span class=p>:</span><span class=mi>8</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>assert</span> <span class=n>version</span> <span class=o>==</span> <span class=mi>2</span><span class=p>,</span> <span class=s2>&#34;wyag 只支持索引文件版本 2&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 从头部解析索引文件中的条目数量（8-12字节）</span>
</span></span><span class=line><span class=cl>    <span class=n>count</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>header</span><span class=p>[</span><span class=mi>8</span><span class=p>:</span><span class=mi>12</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 用于存储读取到的索引条目</span>
</span></span><span class=line><span class=cl>    <span class=n>entries</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 索引文件内容部分从第 12 个字节开始</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>=</span> <span class=n>raw</span><span class=p>[</span><span class=mi>12</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=n>idx</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 循环解析每个条目，根据文件头部给出的条目数进行循环</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>count</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 解析创建时间（秒数和纳秒数）</span>
</span></span><span class=line><span class=cl>        <span class=n>ctime_s</span> <span class=o>=</span>  <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=p>:</span> <span class=n>idx</span><span class=o>+</span><span class=mi>4</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>ctime_ns</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>4</span><span class=p>:</span> <span class=n>idx</span><span class=o>+</span><span class=mi>8</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 解析修改时间（秒数和纳秒数）</span>
</span></span><span class=line><span class=cl>        <span class=n>mtime_s</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>8</span><span class=p>:</span> <span class=n>idx</span><span class=o>+</span><span class=mi>12</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>mtime_ns</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>12</span><span class=p>:</span> <span class=n>idx</span><span class=o>+</span><span class=mi>16</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 解析设备 ID</span>
</span></span><span class=line><span class=cl>        <span class=n>dev</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>16</span><span class=p>:</span> <span class=n>idx</span><span class=o>+</span><span class=mi>20</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 解析 inode 编号</span>
</span></span><span class=line><span class=cl>        <span class=n>ino</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>20</span><span class=p>:</span> <span class=n>idx</span><span class=o>+</span><span class=mi>24</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 忽略的字段</span>
</span></span><span class=line><span class=cl>        <span class=n>unused</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>24</span><span class=p>:</span> <span class=n>idx</span><span class=o>+</span><span class=mi>26</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>assert</span> <span class=mi>0</span> <span class=o>==</span> <span class=n>unused</span>
</span></span><span class=line><span class=cl>        <span class=c1># 解析文件模式（包括类型和权限）</span>
</span></span><span class=line><span class=cl>        <span class=n>mode</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>26</span><span class=p>:</span> <span class=n>idx</span><span class=o>+</span><span class=mi>28</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>mode_type</span> <span class=o>=</span> <span class=n>mode</span> <span class=o>&gt;&gt;</span> <span class=mi>12</span>
</span></span><span class=line><span class=cl>        <span class=k>assert</span> <span class=n>mode_type</span> <span class=ow>in</span> <span class=p>[</span><span class=mb>0b1000</span><span class=p>,</span> <span class=mb>0b1010</span><span class=p>,</span> <span class=mb>0b1110</span><span class=p>]</span>  <span class=c1># 文件类型必须是常规文件、符号链接或 gitlink</span>
</span></span><span class=line><span class=cl>        <span class=n>mode_perms</span> <span class=o>=</span> <span class=n>mode</span> <span class=o>&amp;</span> <span class=mb>0b0000000111111111</span>
</span></span><span class=line><span class=cl>        <span class=c1># 解析用户 ID 和组 ID</span>
</span></span><span class=line><span class=cl>        <span class=n>uid</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>28</span><span class=p>:</span> <span class=n>idx</span><span class=o>+</span><span class=mi>32</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>gid</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>32</span><span class=p>:</span> <span class=n>idx</span><span class=o>+</span><span class=mi>36</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 解析文件大小</span>
</span></span><span class=line><span class=cl>        <span class=n>fsize</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>36</span><span class=p>:</span> <span class=n>idx</span><span class=o>+</span><span class=mi>40</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 解析 SHA（对象 ID），并格式化为 40 字符的小写十六进制字符串</span>
</span></span><span class=line><span class=cl>        <span class=n>sha</span> <span class=o>=</span> <span class=nb>format</span><span class=p>(</span><span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>40</span><span class=p>:</span> <span class=n>idx</span><span class=o>+</span><span class=mi>60</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>),</span> <span class=s2>&#34;040x&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 解析标志位</span>
</span></span><span class=line><span class=cl>        <span class=n>flags</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>60</span><span class=p>:</span> <span class=n>idx</span><span class=o>+</span><span class=mi>62</span><span class=p>],</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 解析假定有效标志位</span>
</span></span><span class=line><span class=cl>        <span class=n>flag_assume_valid</span> <span class=o>=</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=mb>0b1000000000000000</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=c1># 解析扩展标志位（被忽略）</span>
</span></span><span class=line><span class=cl>        <span class=n>flag_extended</span> <span class=o>=</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=mb>0b0100000000000000</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>assert</span> <span class=ow>not</span> <span class=n>flag_extended</span>
</span></span><span class=line><span class=cl>        <span class=c1># 解析阶段标志位</span>
</span></span><span class=line><span class=cl>        <span class=n>flag_stage</span> <span class=o>=</span>  <span class=n>flags</span> <span class=o>&amp;</span> <span class=mb>0b0011000000000000</span>
</span></span><span class=line><span class=cl>        <span class=c1># 解析文件名长度（12 位）</span>
</span></span><span class=line><span class=cl>        <span class=n>name_length</span> <span class=o>=</span> <span class=n>flags</span> <span class=o>&amp;</span> <span class=mb>0b0000111111111111</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 读取了 62 个字节，继续处理文件名</span>
</span></span><span class=line><span class=cl>        <span class=n>idx</span> <span class=o>+=</span> <span class=mi>62</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 如果文件名长度小于 0xFFF，则文件名之后有一个空字节终止符</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>name_length</span> <span class=o>&lt;</span> <span class=mh>0xFFF</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>assert</span> <span class=n>content</span><span class=p>[</span><span class=n>idx</span> <span class=o>+</span> <span class=n>name_length</span><span class=p>]</span> <span class=o>==</span> <span class=mh>0x00</span>
</span></span><span class=line><span class=cl>            <span class=n>raw_name</span> <span class=o>=</span> <span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=p>:</span><span class=n>idx</span><span class=o>+</span><span class=n>name_length</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>idx</span> <span class=o>+=</span> <span class=n>name_length</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 处理文件名长度大于等于 0xFFF 的情况，需要查找空字节终止符</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;注意: 文件名长度为 0x</span><span class=si>{</span><span class=n>name_length</span><span class=si>:</span><span class=s2>X</span><span class=si>}</span><span class=s2> 字节长。&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>null_idx</span> <span class=o>=</span> <span class=n>content</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>idx</span> <span class=o>+</span> <span class=mh>0xFFF</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>raw_name</span> <span class=o>=</span> <span class=n>content</span><span class=p>[</span><span class=n>idx</span><span class=p>:</span> <span class=n>null_idx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>idx</span> <span class=o>=</span> <span class=n>null_idx</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 将文件名解析为 UTF-8 字符串</span>
</span></span><span class=line><span class=cl>        <span class=n>name</span> <span class=o>=</span> <span class=n>raw_name</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s2>&#34;utf8&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 索引文件中的数据以 8 字节对齐，因此需要根据指针对齐调整 idx</span>
</span></span><span class=line><span class=cl>        <span class=n>idx</span> <span class=o>=</span> <span class=mi>8</span> <span class=o>*</span> <span class=n>ceil</span><span class=p>(</span><span class=n>idx</span> <span class=o>/</span> <span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 将解析出的索引条目添加到列表中</span>
</span></span><span class=line><span class=cl>        <span class=n>entries</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>GitIndexEntry</span><span class=p>(</span><span class=n>ctime</span><span class=o>=</span><span class=p>(</span><span class=n>ctime_s</span><span class=p>,</span> <span class=n>ctime_ns</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                                     <span class=n>mtime</span><span class=o>=</span><span class=p>(</span><span class=n>mtime_s</span><span class=p>,</span>  <span class=n>mtime_ns</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                                     <span class=n>dev</span><span class=o>=</span><span class=n>dev</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=n>ino</span><span class=o>=</span><span class=n>ino</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=n>mode_type</span><span class=o>=</span><span class=n>mode_type</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=n>mode_perms</span><span class=o>=</span><span class=n>mode_perms</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=n>uid</span><span class=o>=</span><span class=n>uid</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=n>gid</span><span class=o>=</span><span class=n>gid</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=n>fsize</span><span class=o>=</span><span class=n>fsize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=n>sha</span><span class=o>=</span><span class=n>sha</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=n>flag_assume_valid</span><span class=o>=</span><span class=n>flag_assume_valid</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=n>flag_stage</span><span class=o>=</span><span class=n>flag_stage</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=n>name</span><span class=o>=</span><span class=n>name</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 返回包含所有索引条目的 GitIndex 实例</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>GitIndex</span><span class=p>(</span><span class=n>version</span><span class=o>=</span><span class=n>version</span><span class=p>,</span> <span class=n>entries</span><span class=o>=</span><span class=n>entries</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>index_write</span><span class=p>(</span><span class=n>repo</span><span class=p>,</span> <span class=n>index</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>repo_file</span><span class=p>(</span><span class=n>repo</span><span class=p>,</span> <span class=s2>&#34;index&#34;</span><span class=p>),</span> <span class=s2>&#34;wb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 写入头部信息</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 写入魔术字节 &#34;DIRC&#34; 以标识该文件为 Git 索引文件。</span>
</span></span><span class=line><span class=cl>        <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;DIRC&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 写入版本号（固定为 2）。</span>
</span></span><span class=line><span class=cl>        <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>index</span><span class=o>.</span><span class=n>version</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=c1># 写入索引条目数量。</span>
</span></span><span class=line><span class=cl>        <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>index</span><span class=o>.</span><span class=n>entries</span><span class=p>)</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 写入条目数据</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>idx</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>e</span> <span class=ow>in</span> <span class=n>index</span><span class=o>.</span><span class=n>entries</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 写入创建时间（秒）和创建时间的纳秒部分。</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>e</span><span class=o>.</span><span class=n>ctime</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>e</span><span class=o>.</span><span class=n>ctime</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=c1># 写入修改时间（秒）和修改时间的纳秒部分。</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>e</span><span class=o>.</span><span class=n>mtime</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>e</span><span class=o>.</span><span class=n>mtime</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=c1># 写入设备号和 inode 号。</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>e</span><span class=o>.</span><span class=n>dev</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>e</span><span class=o>.</span><span class=n>ino</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 写入文件权限模式（类型和权限合并）。</span>
</span></span><span class=line><span class=cl>            <span class=n>mode</span> <span class=o>=</span> <span class=p>(</span><span class=n>e</span><span class=o>.</span><span class=n>mode_type</span> <span class=o>&lt;&lt;</span> <span class=mi>12</span><span class=p>)</span> <span class=o>|</span> <span class=n>e</span><span class=o>.</span><span class=n>mode_perms</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>mode</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 写入用户 ID 和组 ID。</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>e</span><span class=o>.</span><span class=n>uid</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>e</span><span class=o>.</span><span class=n>gid</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 写入文件大小。</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>e</span><span class=o>.</span><span class=n>fsize</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=c1># 写入 SHA-1 对象 ID。</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>e</span><span class=o>.</span><span class=n>sha</span><span class=p>,</span> <span class=mi>16</span><span class=p>)</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>20</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 处理标志位 `flag_assume_valid`。</span>
</span></span><span class=line><span class=cl>            <span class=n>flag_assume_valid</span> <span class=o>=</span> <span class=mh>0x1</span> <span class=o>&lt;&lt;</span> <span class=mi>15</span> <span class=k>if</span> <span class=n>e</span><span class=o>.</span><span class=n>flag_assume_valid</span> <span class=k>else</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 将文件名编码为 UTF-8，并计算长度。</span>
</span></span><span class=line><span class=cl>            <span class=n>name_bytes</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=n>name</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s2>&#34;utf8&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>bytes_len</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>name_bytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>bytes_len</span> <span class=o>&gt;=</span> <span class=mh>0xFFF</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>name_length</span> <span class=o>=</span> <span class=mh>0xFFF</span>  <span class=c1># 长度过长时，标记为 0xFFF。</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>name_length</span> <span class=o>=</span> <span class=n>bytes_len</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 将 `flag_assume_valid`、`flag_stage` 和名称长度合并到 2 个字节中。</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>((</span><span class=n>flag_assume_valid</span> <span class=o>|</span> <span class=n>e</span><span class=o>.</span><span class=n>flag_stage</span> <span class=o>|</span> <span class=n>name_length</span><span class=p>)</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 写入文件名，并附加一个 0x00 作为结尾。</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>name_bytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>((</span><span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 计算当前条目的字节数。</span>
</span></span><span class=line><span class=cl>            <span class=n>idx</span> <span class=o>+=</span> <span class=mi>62</span> <span class=o>+</span> <span class=nb>len</span><span class=p>(</span><span class=n>name_bytes</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 若条目不是 8 字节对齐，则进行填充。</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>idx</span> <span class=o>%</span> <span class=mi>8</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>pad</span> <span class=o>=</span> <span class=mi>8</span> <span class=o>-</span> <span class=p>(</span><span class=n>idx</span> <span class=o>%</span> <span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>((</span><span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=n>pad</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>idx</span> <span class=o>+=</span> <span class=n>pad</span>
</span></span></code></pre></div><p>按照我们前面所说的，<code>git add</code>会根据所修改的文件路径对<code>.git/index</code>文件中的内容进行修改。具体实现方式是从<code>.git/index</code>文件中移除指定路径的条目（不物理删除文件），然后对每个路径，读取文件内容，计算文件的哈希值并获取文件的元数据信息，然后将文件的相关信息添加到<code>.git/index</code>文件中，包括 ctime、mtime、文件权限等，最后将新的索引条目写回索引文件。具体的<code>add</code>函数实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>add</span><span class=p>(</span><span class=n>repo</span><span class=p>,</span> <span class=n>paths</span><span class=p>,</span> <span class=n>delete</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>skip_missing</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 首先调用 rm 函数从索引中移除这些路径的条目，避免重复（不物理删除文件）。</span>
</span></span><span class=line><span class=cl>    <span class=n>rm</span><span class=p>(</span><span class=n>repo</span><span class=p>,</span> <span class=n>paths</span><span class=p>,</span> <span class=n>delete</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>skip_missing</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 获取工作树的根目录路径（末尾加上路径分隔符）</span>
</span></span><span class=line><span class=cl>    <span class=n>worktree</span> <span class=o>=</span> <span class=n>repo</span><span class=o>.</span><span class=n>worktree</span> <span class=o>+</span> <span class=n>os</span><span class=o>.</span><span class=n>sep</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将路径转换为 (绝对路径，相对路径) 的对，并确保它们在工作树内且为文件</span>
</span></span><span class=line><span class=cl>    <span class=n>clean_paths</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>path</span> <span class=ow>in</span> <span class=n>paths</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>abspath</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>abspath</span><span class=p>(</span><span class=n>path</span><span class=p>)</span>  <span class=c1># 获取绝对路径</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=p>(</span><span class=n>abspath</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=n>worktree</span><span class=p>)</span> <span class=ow>and</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>isfile</span><span class=p>(</span><span class=n>abspath</span><span class=p>)):</span>  <span class=c1># 确保路径在工作树内且为文件</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Not a file, or outside the worktree: </span><span class=si>{</span><span class=n>paths</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>  <span class=c1># 如果路径无效或不在工作树内，抛出异常</span>
</span></span><span class=line><span class=cl>        <span class=n>relpath</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>relpath</span><span class=p>(</span><span class=n>abspath</span><span class=p>,</span> <span class=n>repo</span><span class=o>.</span><span class=n>worktree</span><span class=p>)</span>  <span class=c1># 获取相对路径</span>
</span></span><span class=line><span class=cl>        <span class=n>clean_paths</span><span class=o>.</span><span class=n>add</span><span class=p>((</span><span class=n>abspath</span><span class=p>,</span> <span class=n>relpath</span><span class=p>))</span>  <span class=c1># 添加到 clean_paths 集合中</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 查找并读取索引。由于 `rm` 已经修改了索引，这里再次读取。</span>
</span></span><span class=line><span class=cl>    <span class=c1># @FIXME：可以通过传递命令来移动索引，而不是反复读写索引。</span>
</span></span><span class=line><span class=cl>    <span class=n>index</span> <span class=o>=</span> <span class=n>index_read</span><span class=p>(</span><span class=n>repo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 遍历每个路径对，读取文件，生成哈希并更新索引条目</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>abspath</span><span class=p>,</span> <span class=n>relpath</span><span class=p>)</span> <span class=ow>in</span> <span class=n>clean_paths</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>abspath</span><span class=p>,</span> <span class=s2>&#34;rb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>fd</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>sha</span> <span class=o>=</span> <span class=n>object_hash</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=sa>b</span><span class=s2>&#34;blob&#34;</span><span class=p>,</span> <span class=n>repo</span><span class=p>)</span>  <span class=c1># 计算文件的 SHA 哈希值</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>stat</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>stat</span><span class=p>(</span><span class=n>abspath</span><span class=p>)</span>  <span class=c1># 获取文件状态</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 获取文件的创建时间和修改时间（秒和纳秒）</span>
</span></span><span class=line><span class=cl>            <span class=n>ctime_s</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>stat</span><span class=o>.</span><span class=n>st_ctime</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>ctime_ns</span> <span class=o>=</span> <span class=n>stat</span><span class=o>.</span><span class=n>st_ctime_ns</span> <span class=o>%</span> <span class=mi>10</span><span class=o>**</span><span class=mi>9</span>
</span></span><span class=line><span class=cl>            <span class=n>mtime_s</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>stat</span><span class=o>.</span><span class=n>st_mtime</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>mtime_ns</span> <span class=o>=</span> <span class=n>stat</span><span class=o>.</span><span class=n>st_mtime_ns</span> <span class=o>%</span> <span class=mi>10</span><span class=o>**</span><span class=mi>9</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 创建 Git 索引条目对象</span>
</span></span><span class=line><span class=cl>            <span class=n>entry</span> <span class=o>=</span> <span class=n>GitIndexEntry</span><span class=p>(</span><span class=n>ctime</span><span class=o>=</span><span class=p>(</span><span class=n>ctime_s</span><span class=p>,</span> <span class=n>ctime_ns</span><span class=p>),</span> <span class=n>mtime</span><span class=o>=</span><span class=p>(</span><span class=n>mtime_s</span><span class=p>,</span> <span class=n>mtime_ns</span><span class=p>),</span> <span class=n>dev</span><span class=o>=</span><span class=n>stat</span><span class=o>.</span><span class=n>st_dev</span><span class=p>,</span> <span class=n>ino</span><span class=o>=</span><span class=n>stat</span><span class=o>.</span><span class=n>st_ino</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>mode_type</span><span class=o>=</span><span class=mb>0b1000</span><span class=p>,</span> <span class=n>mode_perms</span><span class=o>=</span><span class=mo>0o644</span><span class=p>,</span> <span class=n>uid</span><span class=o>=</span><span class=n>stat</span><span class=o>.</span><span class=n>st_uid</span><span class=p>,</span> <span class=n>gid</span><span class=o>=</span><span class=n>stat</span><span class=o>.</span><span class=n>st_gid</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>fsize</span><span class=o>=</span><span class=n>stat</span><span class=o>.</span><span class=n>st_size</span><span class=p>,</span> <span class=n>sha</span><span class=o>=</span><span class=n>sha</span><span class=p>,</span> <span class=n>flag_assume_valid</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>flag_stage</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>name</span><span class=o>=</span><span class=n>relpath</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 将新条目添加到索引条目列表</span>
</span></span><span class=line><span class=cl>            <span class=n>index</span><span class=o>.</span><span class=n>entries</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>entry</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将更新后的索引写回文件</span>
</span></span><span class=line><span class=cl>    <span class=n>index_write</span><span class=p>(</span><span class=n>repo</span><span class=p>,</span> <span class=n>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>rm</span><span class=p>(</span><span class=n>repo</span><span class=p>,</span> <span class=n>paths</span><span class=p>,</span> <span class=n>delete</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>skip_missing</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 查找并读取索引文件</span>
</span></span><span class=line><span class=cl>    <span class=n>index</span> <span class=o>=</span> <span class=n>index_read</span><span class=p>(</span><span class=n>repo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 获取工作树的根目录路径（末尾加上路径分隔符）</span>
</span></span><span class=line><span class=cl>    <span class=n>worktree</span> <span class=o>=</span> <span class=n>repo</span><span class=o>.</span><span class=n>worktree</span> <span class=o>+</span> <span class=n>os</span><span class=o>.</span><span class=n>sep</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将输入路径转换为绝对路径，并确保它们位于工作树内</span>
</span></span><span class=line><span class=cl>    <span class=n>abspaths</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>path</span> <span class=ow>in</span> <span class=n>paths</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>abspath</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>abspath</span><span class=p>(</span><span class=n>path</span><span class=p>)</span>  <span class=c1># 获取绝对路径</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>abspath</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=n>worktree</span><span class=p>):</span>  <span class=c1># 确保路径在工作树中</span>
</span></span><span class=line><span class=cl>            <span class=n>abspaths</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>abspath</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Cannot remove paths outside of worktree: </span><span class=si>{</span><span class=n>paths</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>  <span class=c1># 如果路径不在工作树内，抛出异常</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将要保留的索引条目列表，用于更新索引文件</span>
</span></span><span class=line><span class=cl>    <span class=n>kept_entries</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># 将要删除的路径列表，用于物理删除文件</span>
</span></span><span class=line><span class=cl>    <span class=n>remove</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 遍历索引条目，删除匹配的路径，保留其余条目</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>e</span> <span class=ow>in</span> <span class=n>index</span><span class=o>.</span><span class=n>entries</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>full_path</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>repo</span><span class=o>.</span><span class=n>worktree</span><span class=p>,</span> <span class=n>e</span><span class=o>.</span><span class=n>name</span><span class=p>)</span>  <span class=c1># 获取索引条目的完整路径</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>full_path</span> <span class=ow>in</span> <span class=n>abspaths</span><span class=p>:</span>  <span class=c1># 如果路径在待删除列表中</span>
</span></span><span class=line><span class=cl>            <span class=n>remove</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>full_path</span><span class=p>)</span>  <span class=c1># 加入待删除列表</span>
</span></span><span class=line><span class=cl>            <span class=n>abspaths</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>full_path</span><span class=p>)</span>  <span class=c1># 从待删除路径中移除</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>kept_entries</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>e</span><span class=p>)</span>  <span class=c1># 保留该条目</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 如果有未在索引中找到的路径，且 skip_missing=False，则抛出异常</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>abspaths</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>skip_missing</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Cannot remove paths not in the index: </span><span class=si>{</span><span class=n>abspaths</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 物理删除文件系统中的路径</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>delete</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>path</span> <span class=ow>in</span> <span class=n>remove</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>os</span><span class=o>.</span><span class=n>unlink</span><span class=p>(</span><span class=n>path</span><span class=p>)</span>  <span class=c1># 删除文件</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 更新索引条目，并将其写回索引文件</span>
</span></span><span class=line><span class=cl>    <span class=n>index</span><span class=o>.</span><span class=n>entries</span> <span class=o>=</span> <span class=n>kept_entries</span>
</span></span><span class=line><span class=cl>    <span class=n>index_write</span><span class=p>(</span><span class=n>repo</span><span class=p>,</span> <span class=n>index</span><span class=p>)</span>
</span></span></code></pre></div><p>然后再使用<code>git add</code>之后的<code>.git/index</code>文件生成树对象，最后再借由树对象生成提交对象！！！具体<code>python</code>代码实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>tree_from_index</span><span class=p>(</span><span class=n>repo</span><span class=p>,</span> <span class=n>index</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 初始化一个字典，用于存储目录及其内容，根目录 &#34;&#34; 存储一个空列表。</span>
</span></span><span class=line><span class=cl>    <span class=n>contents</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>contents</span><span class=p>[</span><span class=s2>&#34;&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 遍历索引中的每个条目，构建目录结构。</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>entry</span> <span class=ow>in</span> <span class=n>index</span><span class=o>.</span><span class=n>entries</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>dirname</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>dirname</span><span class=p>(</span><span class=n>entry</span><span class=o>.</span><span class=n>name</span><span class=p>)</span>  <span class=c1># 获取当前条目的目录名</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 遍历目录路径，直到根目录，确保每个目录都被创建</span>
</span></span><span class=line><span class=cl>        <span class=n>key</span> <span class=o>=</span> <span class=n>dirname</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>key</span> <span class=o>!=</span> <span class=s2>&#34;&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>key</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>contents</span><span class=p>:</span>  <span class=c1># 如果该目录尚未在 contents 中，创建一个空列表</span>
</span></span><span class=line><span class=cl>                <span class=n>contents</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>key</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>dirname</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 将条目添加到对应目录的内容列表中</span>
</span></span><span class=line><span class=cl>        <span class=n>contents</span><span class=p>[</span><span class=n>dirname</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>entry</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 获取所有目录的路径并按路径长度从长到短排序</span>
</span></span><span class=line><span class=cl>    <span class=n>sorted_paths</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>contents</span><span class=o>.</span><span class=n>keys</span><span class=p>(),</span> <span class=n>key</span><span class=o>=</span><span class=nb>len</span><span class=p>,</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 初始化树的 SHA-1 哈希（根树的哈希值将会保存在这里）</span>
</span></span><span class=line><span class=cl>    <span class=n>sha</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 遍历排序后的路径（目录），构建树对象</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>path</span> <span class=ow>in</span> <span class=n>sorted_paths</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>tree</span> <span class=o>=</span> <span class=n>GitTree</span><span class=p>()</span>  <span class=c1># 创建一个新的空树对象</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 遍历该目录下的条目，生成树叶并添加到树中</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>entry</span> <span class=ow>in</span> <span class=n>contents</span><span class=p>[</span><span class=n>path</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>entry</span><span class=p>,</span> <span class=n>GitIndexEntry</span><span class=p>):</span>  <span class=c1># 普通的文件条目</span>
</span></span><span class=line><span class=cl>                <span class=c1># 转换文件的权限模式，Git 使用十六进制表示，树对象需要的是八进制 ASCII 字符串</span>
</span></span><span class=line><span class=cl>                <span class=n>leaf_mode</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>entry</span><span class=o>.</span><span class=n>mode_type</span><span class=si>:</span><span class=s2>02o</span><span class=si>}{</span><span class=n>entry</span><span class=o>.</span><span class=n>mode_perms</span><span class=si>:</span><span class=s2>04o</span><span class=si>}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s2>&#34;ascii&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>leaf</span> <span class=o>=</span> <span class=n>GitTreeLeaf</span><span class=p>(</span><span class=n>mode</span><span class=o>=</span><span class=n>leaf_mode</span><span class=p>,</span> <span class=n>path</span><span class=o>=</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>basename</span><span class=p>(</span><span class=n>entry</span><span class=o>.</span><span class=n>name</span><span class=p>),</span> <span class=n>sha</span><span class=o>=</span><span class=n>entry</span><span class=o>.</span><span class=n>sha</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>  <span class=c1># 子目录条目（树）</span>
</span></span><span class=line><span class=cl>                <span class=n>leaf</span> <span class=o>=</span> <span class=n>GitTreeLeaf</span><span class=p>(</span><span class=n>mode</span><span class=o>=</span><span class=sa>b</span><span class=s2>&#34;040000&#34;</span><span class=p>,</span> <span class=n>path</span><span class=o>=</span><span class=n>entry</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>sha</span><span class=o>=</span><span class=n>entry</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>tree</span><span class=o>.</span><span class=n>items</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>leaf</span><span class=p>)</span>  <span class=c1># 将叶子添加到树对象中</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 将生成的树对象写入对象存储，并获取其 SHA-1 哈希</span>
</span></span><span class=line><span class=cl>        <span class=n>sha</span> <span class=o>=</span> <span class=n>object_write</span><span class=p>(</span><span class=n>tree</span><span class=p>,</span> <span class=n>repo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 将树对象的哈希值添加到其父目录的内容列表中，作为一对 (文件名, SHA)</span>
</span></span><span class=line><span class=cl>        <span class=n>parent</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>dirname</span><span class=p>(</span><span class=n>path</span><span class=p>)</span>  <span class=c1># 获取父目录路径</span>
</span></span><span class=line><span class=cl>        <span class=n>base</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>basename</span><span class=p>(</span><span class=n>path</span><span class=p>)</span>   <span class=c1># 获取当前目录的名称（例如 &#34;main.go&#34;）</span>
</span></span><span class=line><span class=cl>        <span class=n>contents</span><span class=p>[</span><span class=n>parent</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>base</span><span class=p>,</span> <span class=n>sha</span><span class=p>))</span>  <span class=c1># 将父目录与新生成的树的哈希值关联</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sha</span>  <span class=c1># 返回根树的 SHA-1 哈希</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>commit_create</span><span class=p>(</span><span class=n>repo</span><span class=p>,</span> <span class=n>tree</span><span class=p>,</span> <span class=n>parent</span><span class=p>,</span> <span class=n>author</span><span class=p>,</span> <span class=n>timestamp</span><span class=p>,</span> <span class=n>message</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>commit</span> <span class=o>=</span> <span class=n>GitCommit</span><span class=p>()</span>  <span class=c1># 创建一个新的提交对象</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 设置提交对象的树字段为当前提交的树对象的 SHA-1 值</span>
</span></span><span class=line><span class=cl>    <span class=n>commit</span><span class=o>.</span><span class=n>kvlm</span><span class=p>[</span><span class=sa>b</span><span class=s2>&#34;tree&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>tree</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s2>&#34;ascii&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 如果有父提交，设置父提交字段</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>parent</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>commit</span><span class=o>.</span><span class=n>kvlm</span><span class=p>[</span><span class=sa>b</span><span class=s2>&#34;parent&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>parent</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s2>&#34;ascii&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 清理提交信息，并在末尾加上换行符</span>
</span></span><span class=line><span class=cl>    <span class=n>message</span> <span class=o>=</span> <span class=n>message</span><span class=o>.</span><span class=n>strip</span><span class=p>()</span> <span class=o>+</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 格式化时区偏移（例如 &#34;+0200&#34; 或 &#34;-0700&#34;）</span>
</span></span><span class=line><span class=cl>    <span class=n>offset</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>timestamp</span><span class=o>.</span><span class=n>astimezone</span><span class=p>()</span><span class=o>.</span><span class=n>utcoffset</span><span class=p>()</span><span class=o>.</span><span class=n>total_seconds</span><span class=p>())</span>  <span class=c1># 获取时区偏移（秒）</span>
</span></span><span class=line><span class=cl>    <span class=n>hours</span> <span class=o>=</span> <span class=n>offset</span> <span class=o>//</span> <span class=mi>3600</span>  <span class=c1># 计算小时</span>
</span></span><span class=line><span class=cl>    <span class=n>minutes</span> <span class=o>=</span> <span class=p>(</span><span class=n>offset</span> <span class=o>%</span> <span class=mi>3600</span><span class=p>)</span> <span class=o>//</span> <span class=mi>60</span>  <span class=c1># 计算分钟</span>
</span></span><span class=line><span class=cl>    <span class=n>tz</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=si>{}{:02}{:02}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=s2>&#34;+&#34;</span> <span class=k>if</span> <span class=n>offset</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=k>else</span> <span class=s2>&#34;-&#34;</span><span class=p>,</span> <span class=n>hours</span><span class=p>,</span> <span class=n>minutes</span><span class=p>)</span>  <span class=c1># 格式化时区字符串</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将作者信息格式化为 &#34;Author Name &lt;email&gt; timestamp timezone&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>author</span> <span class=o>=</span> <span class=n>author</span> <span class=o>+</span> <span class=n>timestamp</span><span class=o>.</span><span class=n>strftime</span><span class=p>(</span><span class=s2>&#34; </span><span class=si>%s</span><span class=s2> &#34;</span><span class=p>)</span> <span class=o>+</span> <span class=n>tz</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 设置提交对象的作者和提交者字段为相同的值</span>
</span></span><span class=line><span class=cl>    <span class=n>commit</span><span class=o>.</span><span class=n>kvlm</span><span class=p>[</span><span class=sa>b</span><span class=s2>&#34;author&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>author</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s2>&#34;utf8&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>commit</span><span class=o>.</span><span class=n>kvlm</span><span class=p>[</span><span class=sa>b</span><span class=s2>&#34;committer&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>author</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s2>&#34;utf8&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 设置提交信息字段</span>
</span></span><span class=line><span class=cl>    <span class=n>commit</span><span class=o>.</span><span class=n>kvlm</span><span class=p>[</span><span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=n>message</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s2>&#34;utf8&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将提交对象写入对象存储，并返回其 SHA-1 哈希</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>object_write</span><span class=p>(</span><span class=n>commit</span><span class=p>,</span> <span class=n>repo</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=git二连击可视化>Git二连击可视化<a hidden class=anchor aria-hidden=true href=#git二连击可视化>#</a></h2><p>已经了解了上面的底层原理后，对Git两连击的的可视化也就十分简单了，详见下图，参考<a href=https://zhuanlan.zhihu.com/p/96631135>这才是真正的Git——Git内部原理揭秘！</a>：
<input type=checkbox id=zoomCheck-ebf77 hidden>
<label for=zoomCheck-ebf77><img class=zoomCheck loading=lazy decoding=async src=./img/object.png alt=image>
</label><input type=checkbox id=zoomCheck-e1011 hidden>
<label for=zoomCheck-e1011><img class=zoomCheck loading=lazy decoding=async src=./img/change.gif alt=gif>
</label><input type=checkbox id=zoomCheck-0d927 hidden>
<label for=zoomCheck-0d927><img class=zoomCheck loading=lazy decoding=async src=./img/add.gif alt=gif>
</label><input type=checkbox id=zoomCheck-c023b hidden>
<label for=zoomCheck-c023b><img class=zoomCheck loading=lazy decoding=async src=./img/commit.gif alt=gif>
</label>现在，😮‍💨，所有Git基础的内容的底层原理以及其代码形式差不多就讲解完了。还有一些比较高级的Git内容我们留待后文。</p><h2 id=git常用命令进阶>Git常用命令进阶<a hidden class=anchor aria-hidden=true href=#git常用命令进阶>#</a></h2><p>我们已经可视化了Git两连击中细节，下面我们可以从高层次的视角（GitCommit）来对Git中的高阶常用命令进行可视化，可视化结果由<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branch</a>提供。我们经过一系列的<code>git add</code>和<code>git commit</code>以及<code>git checkout</code>之后得到的初始的GitCommit的分布情况如图7所示。</p><center><img src=./img/highlevel.png alt=图片1 width=400></center><center><strong>图7：初始GitCommit分布情况</strong></center><p>接下来先介绍的4个命令的联系如图8所示：</p><center><img src=./img/git3.png alt=图片1 width=400></center><center><img src=./img/git3high.png alt=图片1 width=400></center><center><strong>图8：git reset、git checkout、git add和 git commit的联系</strong></center><p><code>git add</code>和<code>git commit</code> 命令我们已经详细介绍过了，下面再简要对对这4个命令进行叙述。</p><ul><li><code>git add files</code> 把当前文件放入暂存区域。</li><li><code>git commit -m message</code> 给暂存区域生成快照并提交，而<code>git commit -a -m message</code>自动将所有被跟踪的文件的更改暂存并提交，省略了<code>git add</code>的步骤。</li><li><code>git reset files</code> 用来撤销最后一次<code>git add files</code>，你也可以用<code>git reset</code> 撤销所有暂存区域文件。</li><li><code>git checkout files</code> 把文件从暂存区域复制到工作目录，用来丢弃本地修改，而<code>git checkout HEAD files</code> 用来将工作目录中指定文件恢复到当前分支最新一次提交时的状态（即 HEAD 指针指向的提交）。这相当于丢弃对这些文件的所有未提交修改，恢复到上一次提交的版本。</li></ul><h3 id=git-checkout><code>git checkout</code><a hidden class=anchor aria-hidden=true href=#git-checkout>#</a></h3><h4 id=分支参数>分支参数<a hidden class=anchor aria-hidden=true href=#分支参数>#</a></h4><p>checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。当不指定文件名，而是给出一个（本地）分支时，那么<code>HEAD</code>标识会移动到那个分支（也就是说，我们“切换”到那个分支了），然后暂存区域和工作目录中的内容会和<code>HEAD</code>对应的提交节点一致。新提交节点（下图中的C1）中的所有文件都会被复制（到暂存区域和工作目录中）；只存在于老的提交节点（C5）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。(分支在<code>.git</code>文件夹中对应<code>.git/refs/heads/</code>中的文件，<code>HEAD</code>对应<code>.git</code>文件夹中的<code>HEAD</code>文件，<code>git checkout stable</code>将<code>HEAD</code>文件内容由<code>ref: refs/heads/main</code>改变成<code>ref: refs/heads/stable</code>同时暂存区和工作目录也会发生变化)</p><center><img src=./img/branch.png alt=图片1 width=400></center><center><strong>图9：git checkout stable将分支从main转换到stable</strong></center><h4 id=被分离的head标识>被分离的HEAD标识<a hidden class=anchor aria-hidden=true href=#被分离的head标识>#</a></h4><p>如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像main~3类似的东西，就得到一个匿名分支，称作detached HEAD（被分离的HEAD标识），暂存区域和工作目录中的内容会和<code>HEAD</code>对应的提交节点一致。</p><center><img src=./img/detached.png alt=图片1 width=400></center><center><strong>图10：git checkout main~3将HEAD分离出来</strong></center><p>HEAD处于分离状态时，提交操作可以正常进行如图11所示，但是不会更新任何已命名的分支。(你可以认为这是在更新一个匿名分支。)一旦此后你切换到别的分支，比如说main，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了，如图12所示。</p><center><img src=./img/detached_commit.png alt=图片1 width=400></center><center><strong>图11：HEAD标识处于分离状态时的提交操作</strong></center><center><img src=./img/detached_main.png alt=图片1 width=400></center><center><strong>图12：git checkout main运行后之前提交节点的情况</strong></center><p>但是，如果你想保存这个状态，可以用命令<code>git checkout -b name</code>来创建一个新的分支，如图13所示。</p><center><img src=./img/new_branch.png alt=图片1 width=400></center><center><strong>图13：git checkout -b new运行后可以保存提交状态</strong></center><h3 id=git-reset><code>git reset</code><a hidden class=anchor aria-hidden=true href=#git-reset>#</a></h3><p>reset命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</p><p>如果不给选项，移动<code>HEAD</code>到指定的提交，并且将更改从暂存区移除，但保留在工作目录中（需要<code>git add</code>和<code>git commit</code>）。如果用<code>--hard</code>选项，移动<code>HEAD</code>到指定的提交，并且重置暂存区和工作目录，如果用<code>--soft</code>选项，仅仅移动<code>HEAD</code>到指定的提交，但保留工作区和暂存区的更改（仅需要<code>git commit</code>）。</p><center><img src=./img/reset.png alt=图片1 width=400></center><center><strong>图14：现将HEAD指向main分支再运行git reset main~3后的情况</strong></center><p>如果没有给出提交点的版本号，那么默认用HEAD。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用<code>--hard</code>选项，工作目录也同样。</p><h3 id=git-merge><code>git merge</code><a hidden class=anchor aria-hidden=true href=#git-merge>#</a></h3><p>merge 命令把不同分支合并起来。合并前，索引必须和当前提交相同。如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。 另一种情况是如果当前提交是另一个分支的祖父节点，就导致fast-forward合并。指向只是简单的移动，并生成一个新的提交。</p><center><img src=./img/merge_before.png alt=图片1 width=400></center><center><strong>图14：运行git merge main前的情况</strong></center><center><img src=./img/merge_after.png alt=图片1 width=400></center><center><strong>图15：运行git merge main后的情况，快速前进</strong></center><p>否则就是一次真正的合并。默认把当前提交(C5 如下所示)和另一个提交(C7)以及他们的共同祖父节点(C2)进行一次<a href=http://en.wikipedia.org/wiki/Three-way_merge>三方合并</a>。结果是先保存当前目录和索引，然后和父节点C7一起做一次新提交。</p><center><img src=./img/merge_before2.png alt=图片1 width=400></center><center><strong>图16：运行git merge main前的情况</strong></center><center><img src=./img/merge_after2.png alt=图片1 width=400></center><center><strong>图17：运行git merge main后的情况，正宗融合</strong></center><h3 id=git-cherry-pick><code>git cherry-pick</code><a hidden class=anchor aria-hidden=true href=#git-cherry-pick>#</a></h3><p><code>git cherry-pick</code>命令"复制"一个提交节点并在当前分支做一次完全一样的新提交，暂存区和工作目录都发生改变。</p><center><img src=./img/cherry_pick_before.png alt=图片1 width=400></center><center><strong>图18：运行git cherry-pick C4之前的情况</strong></center><center><img src=./img/cherry_pick_after.png alt=图片1 width=400></center><center><strong>图19：运行git cherry-pick C4之后的情况，复制C4在当前main分支下做一次完全相同的提交</strong></center>### `git rebase`<p>衍合是合并命令的另一种选择。合并把两个父分支合并进行一次提交，提交历史不是线性的。衍合在当前分支上重演另一个分支的历史，提交历史是线性的。 本质上，这是线性化的自动的 <code>cherry-pick</code>。</p><center><img src=./img/rebase_bug_before.png alt=图片1 width=400></center><center><strong>图20：运行git rebase bugFix之前的情况</strong></center><center><img src=./img/rebase_bug_after.png alt=图片1 width=400></center><center><strong>图21：运行git rebase bugFix之后的情况</strong></center><h2 id=git本地仓库连接并上传远程仓库>Git本地仓库连接并上传远程仓库<a hidden class=anchor aria-hidden=true href=#git本地仓库连接并上传远程仓库>#</a></h2><h3 id=使用ssh密钥将本地git和远程github配对>使用ssh密钥将本地git和远程GitHub配对<a hidden class=anchor aria-hidden=true href=#使用ssh密钥将本地git和远程github配对>#</a></h3><p>参考<a href=https://zhuanlan.zhihu.com/p/138305054>https://zhuanlan.zhihu.com/p/138305054</a></p><h3 id=本地上传远程6步走战略>本地上传远程6步走战略<a hidden class=anchor aria-hidden=true href=#本地上传远程6步走战略>#</a></h3><ul><li><code>git init</code>：将文件夹设置为本地仓库，只有这样才可以把本地的文件传入github仓库。</li><li><code>git remote add origin git@github.com:yourusername/yourprojectname.git</code>：将本地仓库与github仓库进行关联。</li><li><code>git pull origin main(or master)</code>：将GitHub上仓库的内容pull到本地仓库，两者保持一致。</li><li><code>git add</code>：需要上传的文件 添加文件到本地库。（<font color=#ff0000>再次上传就是3步走战略</font>）</li><li><code>git commit -m “information”</code>：提交文件到本地库。（<font color=#ff0000>再次上传就是3步走战略</font>）</li><li><code>git push origin main(or master)</code>：上传文件。（<font color=#ff0000>再次上传就是3步走战略</font>）</li></ul><h2 id=参考网站>参考网站<a hidden class=anchor aria-hidden=true href=#参考网站>#</a></h2><ul><li><a href=https://wyag.thb.lt/#org2e1a2c4>Write yourself a Git!</a></li><li><a href=https://zhuanlan.zhihu.com/p/96631135>这才是真正的Git——Git内部原理揭秘！</a></li><li><a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branch</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://fordelkon.github.io/tags/git/>Git</a></li><li><a href=https://fordelkon.github.io/tags/python/>Python</a></li></ul><nav class=paginav><a class=prev href=https://fordelkon.github.io/posts/cmd_intro_1/><span class=title>« Prev</span><br><span>使用命令行的艺术1</span>
</a><a class=next href=https://fordelkon.github.io/teaching/probdis/><span class=title>Next »</span><br><span>深度学习中常用的概率分布总结</span></a></nav></footer><div class=giscus_comments><script src=https://giscus.app/client.js data-repo=jesse-wei/jessewei.dev-PaperMod data-repo-id=R_kgDOJhJgPg data-category=Comments data-category-id=DIC_kwDOJhJgPs4CWei3 data-mapping=pathname data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><script async>document.querySelector("div.giscus_comments > script").setAttribute("data-theme",localStorage.getItem("pref-theme")?localStorage.getItem("pref-theme"):window.matchMedia("(prefers-color-scheme: dark)").matches?"transparent_dark":"light"),document.querySelector("#theme-toggle").addEventListener("click",()=>{let e=document.querySelector("iframe.giscus-frame");e&&e.contentWindow.postMessage({giscus:{setConfig:{theme:localStorage.getItem("pref-theme")?localStorage.getItem("pref-theme")==="dark"?"light":"transparent_dark":document.body.className.includes("dark")?"light":"transparent_dark"}}},"https://giscus.app")})</script></article></main><footer class=footer style=padding-top:18px;padding-bottom:18px><div class=social-icons style=padding-bottom:0><a style=border-bottom:none href=https://github.com/fordelkon rel=me title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a style=border-bottom:none href=https://x.com/fordelkon rel=me title=Twitter><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg>
</a><a style=border-bottom:none href=mailto:dlkong201893@gmail.com rel=me title=Email><svg viewBox="0 0 24 21" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div><span>&copy; 2025 <a href=https://fordelkon.github.io/>DL Kong</a></span>
<span>•
Powered by
<a href=https://gohugo.io/>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/>PaperMod</a>
</span><span>•
<a href=/privacy>Privacy Policy</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let b=document.querySelector("#menu-trigger"),m=document.querySelector(".menu");b.addEventListener("click",function(){m.classList.toggle("hidden")}),document.body.addEventListener("click",function(e){b.contains(e.target)||m.classList.add("hidden")})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用命令行的艺术1 | DL Kong</title><meta name=keywords content="Shell,Linux,Docker"><meta name=description content="熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文旨在了解命令行的Shell语言的一些基础概念和有关使用命令行的Shell的一些快捷操作，额外带一些Linux系统中系统文件说明&mldr;"><meta name=author content="DL Kong"><link rel=canonical href=https://fordelkon.github.io/posts/cmd_intro_1/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.c7a0847263ef81d155d535eb3508757a49b1a3680807f60ed1f64e9d4a686070.css integrity="sha256-x6CEcmPvgdFV1TXrNQh1ekmxo2gIB/YO0fZOnUpoYHA=" rel="preload stylesheet" as=style><link rel=icon href=https://fordelkon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://fordelkon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fordelkon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://fordelkon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://fordelkon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://fordelkon.github.io/posts/cmd_intro_1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><style>@media screen and (min-width:769px){.post-content input[type=checkbox]:checked~label>img{transform:scale(1.6);cursor:zoom-out;position:relative;z-index:999}.post-content img.zoomCheck{transition:transform .15s ease;z-index:999;cursor:zoom-in}}</style><link rel=stylesheet href=/css/extended/xcode.css media="(prefers-color-scheme: light)"><link rel=stylesheet href=/css/extended/monokai.css media="(prefers-color-scheme: dark)"><script async src="https://www.googletagmanager.com/gtag/js?id=G-Q603T56FWT"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Q603T56FWT")}</script><meta property="og:url" content="https://fordelkon.github.io/posts/cmd_intro_1/"><meta property="og:site_name" content="DL Kong"><meta property="og:title" content="使用命令行的艺术1"><meta property="og:description" content="熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文旨在了解命令行的Shell语言的一些基础概念和有关使用命令行的Shell的一些快捷操作，额外带一些Linux系统中系统文件说明…"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-25T13:40:00+09:00"><meta property="article:modified_time" content="2025-08-25T13:40:00+09:00"><meta property="article:tag" content="Shell"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Docker"><meta property="og:image" content="https://fordelkon.github.io/img/cmdart.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://fordelkon.github.io/img/cmdart.png"><meta name=twitter:title content="使用命令行的艺术1"><meta name=twitter:description content="熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文旨在了解命令行的Shell语言的一些基础概念和有关使用命令行的Shell的一些快捷操作，额外带一些Linux系统中系统文件说明&mldr;"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fordelkon.github.io/posts/"},{"@type":"ListItem","position":2,"name":"使用命令行的艺术1","item":"https://fordelkon.github.io/posts/cmd_intro_1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用命令行的艺术1","name":"使用命令行的艺术1","description":"熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文旨在了解命令行的Shell语言的一些基础概念和有关使用命令行的Shell的一些快捷操作，额外带一些Linux系统中系统文件说明\u0026hellip;\n","keywords":["Shell","Linux","Docker"],"articleBody":"熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文旨在了解命令行的Shell语言的一些基础概念和有关使用命令行的Shell的一些快捷操作，额外带一些Linux系统中系统文件说明…\n使用docker拉取Ubuntu容器 由于本人的笔记本并非Linux操作系统，为了方便命令行的学习而又不想搭建虚拟机双开系统，我们使用Docker来拉取一个Ubuntu镜像来方便我们学习，有关Docker的介绍参考我的另一篇文章使用Docker的艺术。\n拉取Ubuntu镜像 docker pull ubuntu 运行一个交互式的 Ubuntu 容器 docker run -it ubuntu docker run会根据后面的镜像名称拉起一个新的容器并进入它的命令行。-it 标志表示以交互模式启动，并连接到该容器的终端。进入容器后，你将获得一个完全隔离的 Linux 系统，可以像平常一样使用 Shell。\n退出容器 你可以在Linux系统中运行 exit 命令来退出容器。默认情况下，当你退出容器后，容器也会自动停止。如果你想保持容器在后台运行，可以通过以下方式运行容器： docker run -d ubuntu 重新进入容器 如果是在Linux系统中运行exit命令后，退出容器后容器自动停止，此时再想打开这个容器的话我们先运行以下命令可以查看所有的容器（包括已经停止的），我们可以从中找到我们的容器ID。 docker ps -a # 查看所有的容器，包括停止的 我的电脑上输出的结果是：\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 3a8357da8968 ubuntu \"/bin/bash\" 2 minutes ago Exited (0) About a minute ago tender_elbakyan 然后再根据容器ID启动一个停止的容器：\ndocker start 3a8357da8968 docker exec会进入一个已经在运行的容器：\ndocker exec -it 3a8357da8968 /bin/bash 删除容器和镜像 当我们不在需要容器和镜像的时候，可以删除容器和镜像来节省内存。首先根据容器ID删除容器： docker rm 3a8357da8968 再根据镜像ID删除镜像。先得到镜像ID：\ndocker images 我的电脑的运行结果是：\nREPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest c3d1a3432580 6 weeks ago 101MB 再删除镜像：\ndocker rmi c3d1a3432580 Bash Shell Linux系统文件中的shell Shell（壳程序）可以提供使用者操作应用程序的接口。/bin/bash是Linux默认的shell，Linux可用的shell记录在/etc/shells中，我们可以通过以下命令查看Linux可用的shells：\ncat /etc/shells 得到的输出是：\n# /etc/shells: valid login shells /bin/sh /usr/bin/sh /bin/bash /usr/bin/bash /bin/rbash /usr/bin/rbash /usr/bin/dash 登陆Linux系统时，系统会给予一个shell，这个登陆取得的shell记录在/etc/passwd中，可以通过以下命令查看：\ncat /etc/passwd 得到的输出是：\nroot@611b47761989:/# cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin ......（下面省略）...... bash shell的功能 记忆使用过的指令（记录的指令在~/.bash_history中） 命令与文件的补全（使用tab键，两次连按tab键会对匹配的命令或文件进行显示，如果只有一个与之匹配的命令或文件，则一次tab键会自动补全） 设置命令别名 比如要现实目录下面的所有文件 （包含隐藏文件） 及所有的文件属性，我们可以运行以下命令： ls -al 但我们又是嫌弃这样写太过麻烦，我们可以对以上命令进行别名命名：\nalias lm='ls -al' 那么lm的功能就和之前的ls -al功能一致了。\n程序化脚本（shell script） 万用字符匹配*（指令列输入指令的万用字符，不带引号） 符号 意义 * 代表“ 0 个到无穷多个”任意字符 ? 代表“一定有一个”任意字符 [ ] 同样代表“一定有一个在括号内”的字符（非任意字符）。例如[abcd] 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个” [ - ] 若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如[0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！ [^ ] 若中括号内的第一个字符为指数符号 （^） ，那表示“反向选择”，例如 [^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。 与命令行相关的特殊符号 # 注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行 \\ 跳脱符号：将“特殊字符或万用字符”还原成一般字符 | 管道（pipe）：分隔两个管线命令的界定； ; 连续指令下达分隔符号：连续性命令的界定 （注意！与管线命令并不相同） ~ 使用者的主文件夹 $ 取用变量前置字符：亦即是变量之前需要加的变量取代值 \u0026 工作控制 （job control）：将指令变成背景下工作 ! 逻辑运算意义上的“非” not 的意思！ / 目录符号：路径分隔的符号 \u003e, » 数据流重导向：输出导向，分别是“取代”与“累加” \u003c, « 数据流重导向：输入导向 ’ ' 单引号，不具有变量置换的功能 （$ 变为纯文本） \" \" 具有变量置换的功能！ （$ 可保留相关功能） 两个“ ` ”中间为可以先执行的指令，亦可使用 $（ ） （ ） 在中间为子 shell 的起始与结束 { } 在中间为命令区块的组合！ bash shell的内置命令查询：type 通过type指令我们可以知道每个指令是否为 bash 的内置指令，此外利用type搜寻后面的名称时，如果后面接的名称并不能以可执行文件的状态被找到， 那么该名称是不会被显示出来的。因此我们可以也可以直接运行可执行文件来代替原命令。\ntype -a ls 得到的输出为：\nls is aliased to `ls --color=auto' ls is /usr/bin/ls ls is /bin/ls 因此我们也可以直接运行/usr/bin/ls或/bin/ls来代替ls。找指令也可以使用which。\nbash shell中的快速编辑按钮 ctrl-r搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下ctrl-r会向后查找匹配项，按下Enter键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。 ctrl-w删除你键入的最后一个单词，ctrl-u可以删除行内光标所在位置之前的内容，alt-b和 alt-f可以以单词为单位移动光标，ctrl-a可以将光标移至行首，ctrl-e可以将光标移至行尾，ctrl-k可以删除光标至行尾的所有内容，ctrl-l可以清屏。键入 man readline 可以查看 Bash 中的默认快捷键。内容有很多，例如 alt-.循环地移向前一个参数，而alt-*可以展开通配符。 shell的变量 字符串和数组是 Shell 中最常用的变量类型。 如果变量类型是数组，我们可以通过以下方式遍历所有元素：\nnames=(\"delkon\" \"ikun\" \"bob\") echo \"${names[@]}\" # delkon ikun bob # 但是下面的命令只能索引到第一个元素 echo \"$names\" delkon 使用echo命令可以读出变量 echo ${variable}读出variable的值(variable是字符串) echo $(command)读出command的stdout echo $((expression))读出表达式的值\n系统自带的环境变量 利用etc观察系统自带环境变量如下：\nHOSTNAME=611b47761989 # 这部主机的主机名称 PWD=/ # 当前工作目录 HOME=/root # 当前用户的主目录 LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=00:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.avif=01;35:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:*~=00;90:*#=00;90:*.bak=00;90:*.crdownload=00;90:*.dpkg-dist=00;90:*.dpkg-new=00;90:*.dpkg-old=00;90:*.dpkg-tmp=00;90:*.old=00;90:*.orig=00;90:*.part=00;90:*.rej=00;90:*.rpmnew=00;90:*.rpmorig=00;90:*.rpmsave=00;90:*.swp=00;90:*.tmp=00;90:*.ucf-dist=00;90:*.ucf-new=00;90:*.ucf-old=00;90: TERM=xterm # 这个终端机使用的环境是什么类型 SHLVL=1 # 当前 shell 会话的深度层级 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin # 系统搜索可执行文件的路径列表 _=/usr/bin/env # 这是最后一个执行命令的路径 比较重要的除了上面介绍的之外还有一个RANDOM变量，在 BASH 的环境下，这个 RANDOM 变量的内容，介于 0~32767 之间，由/dev/random乱数器产生。\nbash内的自订变量 利用set命令观察bash内的其他变量如下：\nBASH=/bin/bash ...... BASH_ALIASES=() BASH_ARGC=([0]=\"0\") BASH_ARGV=() BASH_CMDS=() BASH_LINENO=() BASH_LOADABLES_PATH=/usr/local/lib/bash:/usr/lib/bash:/opt/local/lib/bash:/usr/pkg/lib/bash:/opt/pkg/lib/bash:. BASH_SOURCE=() BASH_VERSINFO=([0]=\"5\" [1]=\"2\" [2]=\"21\" [3]=\"1\" [4]=\"release\" [5]=\"aarch64-unknown-linux-gnu\") BASH_VERSION='5.2.21(1)-release' COLUMNS=80 DIRSTACK=() EUID=0 GROUPS=() HISTCONTROL=ignoredups:ignorespace HISTFILE=/root/.bash_history HISTFILESIZE=2000 HISTSIZE=1000 HOME=/root HOSTNAME=611b47761989 HOSTTYPE=aarch64 IFS=$' \\t\\n' LINES=25 ...... MACHTYPE=aarch64-unknown-linux-gnu MAILCHECK=60 OPTERR=1 OPTIND=1 OSTYPE=linux-gnu PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin PIPESTATUS=([0]=\"0\") PPID=0 PS1='\\[\\e]0;\\u@\\h: \\w\\a\\]${debian_chroot:+($debian_chroot)}\\u@\\h:\\w\\$ ' PS2='\u003e ' PS4='+ ' PWD=/ SHELL=/bin/bash SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor SHLVL=1 TERM=xterm UID=0 _=clear 上面的变量有一些比较重要，我们分而述之。\nPS1：（提示字符的设置） 当我们每次按下enter键去执行某个指令后，最后要再次出现提示符时就会去读取这个变量值。 PS1='\\[\\e]0;\\u@\\h: \\w\\a\\]${debian_chroot:+($debian_chroot)}\\u@\\h:\\w\\$ ' 其中\\[\\e]0;...\\a\\]: 这是一个 ANSI 转义序列，用于在支持的终端中设置窗口的标题或图标。${debian_chroot:+($debian_chroot)}是条件表达式，用于在 Debian 或其他带有 chroot 环境时显示当前的 chroot 名称。\\u@\\h显示格式为 用户名@主机名，\\w显示当前的工作目录，最后\\$根据当前用户是否是超级用户显示不同的符号。还有一些其他比较有意思的符号，比如\n# ： 下达的第几个指令。 \\t ：显示时间，为 24 小时格式的“HH:MM:SS” \\T ：显示时间，为 12 小时格式的“HH:MM:SS” \\A ：显示时间，为 24 小时格式的“HH:MM” \\@ ：显示时间，为 12 小时格式的“am/pm”样式 $：本shell的PID 我们可以运行echo ${$}来展示本shell的PID号码，结果如下: 51 ?：上个执行指令的回传值 如果成功的执行上个指令， 则会回传一个 0 值，如果执行过程发生错误，就会回传非为 0 的数值。具体情形如下所示： cd cati 结果为：\nbash: cd: cati: No such file or directory 再运行：\necho ${?} 结果为：\n1 自订变量和环境变量的转换 自订变量转成环境变量 采用export命令或declare -x： export variable declare -x variable 环境变量（由自订变量转换而成的环境变量）转成自订变量 declare [-aixr] variable 选项与参数： -a ：将后面名为 variable 的变量定义成为阵列 （array） 类型 -i ：将后面名为 variable 的变量定义成为整数数字 （integer） 类型 -x ：用法与 export 一样，就是将后面的 variable 变成环境变量； -r ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset 采用declare +x:\ndeclare +x variable bash中与变量扩展方式 #：从字符串开头删除与pattern匹配的最短部分，并返回剩下的字符串。也可以用来获取变量的字符长度。 语法：${variable#pattern} 语法：${#variable} ##：从字符串开头删除与pattern匹配的最长部分，并返回剩下的字符串。 语法：${variable##pattern} 具体示例如下：\nstr=abc.defg.hijkl.txt echo ${str#*.} # defg.hijkl.txt echo ${str##*.} # txt %: 从字符串末尾删除与 pattern 匹配的最短部分，并返回剩下的字符串。 语法：${variable%pattern} %%：从字符串末尾删除与 pattern 匹配的最短部分，并返回剩下的字符串。 语法：${variable%%pattern} 具体示例如下： echo ${str%.*} # abc.defg.hijkl echo ${str%%.*} # abc /：将变量 variable 中第一个匹配 pattern 的部分替换为 replacement。 语法：${variable/pattern/replacement} //：将变量 variable 中所有匹配 pattern 的部分替换为 replacement。 语法：${variable//pattern/replacement} 具体示例如下： fname=delkon-university-works echo ${fname/-/_} # delkon_university-works echo ${fname//-/_} # delkon_university_works :-：如果变量未定义或为空，则返回default值。 语法：${variable:-default} :=：如果变量未定义或为空，则将其赋值为 default。 语法：${variable:=default} :+：如果变量已定义且不为空，则返回 replacement，否则返回空字符串。 语法：${variable:+replacement} :?：如果变量未定义或为空，则输出 error 消息并退出脚本。 语法：${variable:?error} 具体一些情况如下表格所示：\n变量设置方式 str 没有设置 str 为空字串 str 已设置非为空字串 var=${str-expr} var=expr var= var=$str var=${str:-expr} var=expr var=expr var=$str var=${str+expr} var= var=expr var=expr var=${str:+expr} var= var= var=expr var=${str=expr} str=expr var=expr str 不变 var= str 不变 var=$str var=${str:=expr} str=expr var=expr str=expr var=expr str 不变 var=$str var=${str?expr} expr 输出至 stderr var= var=$str var=${str:?expr} expr 输出至 stderr expr 输出至 stderr var=$str ${variable:offset}和${variable:offset:length}用来从变量中提取子字符串。 bash配置 source或.后接配置文件会立即使用该配置文件。\n","wordCount":"617","inLanguage":"en","image":"https://fordelkon.github.io/img/cmdart.png","datePublished":"2025-08-25T13:40:00+09:00","dateModified":"2025-08-25T13:40:00+09:00","author":{"@type":"Person","name":"DL Kong"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://fordelkon.github.io/posts/cmd_intro_1/"},"publisher":{"@type":"Organization","name":"DL Kong","logo":{"@type":"ImageObject","url":"https://fordelkon.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fordelkon.github.io/ accesskey=h title="DL Kong (Alt + H)"><img src=https://fordelkon.github.io/logo_filled_outlined_6.png alt="Site icon in header" aria-label=logo height=35>DL Kong</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><button id=menu-trigger aria-haspopup=menu aria-label="Menu Button">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><ul class="menu hidden"><li><a href=https://fordelkon.github.io/about/ title=About><span>About</span></a></li><li><a href=https://fordelkon.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://fordelkon.github.io/teaching/ title=Teaching><span>Teaching</span></a></li><li><a href=https://fordelkon.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fordelkon.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://fordelkon.github.io/posts/>Posts</a></div><h1 class=post-title>使用命令行的艺术1</h1><div class=post-meta><span title='2025-08-25 13:40:00 +0900 +0900'>August 8, 25000</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;DL Kong</div></header><div class="toc side left"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#使用docker拉取ubuntu容器>使用docker拉取Ubuntu容器</a></li><li><a href=#bash-shell>Bash Shell</a><ul><li><a href=#linux系统文件中的shell>Linux系统文件中的shell</a></li><li><a href=#bash-shell的功能>bash shell的功能</a></li><li><a href=#bash-shell的内置命令查询type>bash shell的内置命令查询：type</a></li><li><a href=#bash-shell中的快速编辑按钮>bash shell中的快速编辑按钮</a></li><li><a href=#shell的变量>shell的变量</a></li><li><a href=#系统自带的环境变量>系统自带的环境变量</a></li><li><a href=#bash内的自订变量>bash内的自订变量</a></li><li><a href=#自订变量和环境变量的转换>自订变量和环境变量的转换</a></li><li><a href=#bash中与变量扩展方式>bash中与变量扩展方式</a></li><li><a href=#bash配置>bash配置</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文旨在了解命令行的Shell语言的一些基础概念和有关使用命令行的Shell的一些快捷操作，额外带一些Linux系统中系统文件说明&mldr;</p><h2 id=使用docker拉取ubuntu容器>使用docker拉取Ubuntu容器<a hidden class=anchor aria-hidden=true href=#使用docker拉取ubuntu容器>#</a></h2><p>由于本人的笔记本并非Linux操作系统，为了方便命令行的学习而又不想搭建虚拟机双开系统，我们使用Docker来拉取一个Ubuntu镜像来方便我们学习，有关Docker的介绍参考我的另一篇文章<a href=/posts/docker_intro>使用Docker的艺术</a>。</p><ul><li>拉取Ubuntu镜像</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker pull ubuntu
</span></span></code></pre></div><ul><li>运行一个交互式的 Ubuntu 容器</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -it ubuntu
</span></span></code></pre></div><p><code>docker run</code>会根据后面的镜像名称拉起一个<strong>新的容器</strong>并进入它的命令行。<code>-it </code>标志表示以交互模式启动，并连接到该容器的终端。进入容器后，你将获得一个完全隔离的 Linux 系统，可以像平常一样使用 Shell。</p><ul><li>退出容器
你可以在Linux系统中运行 <code>exit</code> 命令来退出容器。默认情况下，当你退出容器后，容器也会自动停止。如果你想保持容器在后台运行，可以通过以下方式运行容器：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -d ubuntu
</span></span></code></pre></div><ul><li>重新进入容器
如果是在Linux系统中运行exit命令后，退出容器后容器自动停止，此时再想打开这个容器的话我们先运行以下命令可以查看所有的容器（包括已经停止的），我们可以从中找到我们的容器ID。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker ps -a
</span></span><span class=line><span class=cl><span class=c1># 查看所有的容器，包括停止的</span>
</span></span></code></pre></div><p>我的电脑上输出的结果是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS         PORTS     NAMES
</span></span><span class=line><span class=cl>3a8357da8968   ubuntu    &#34;/bin/bash&#34;   2 minutes ago   Exited (0) About a minute ago             tender_elbakyan
</span></span></code></pre></div><p>然后再根据容器ID启动一个停止的容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker start 3a8357da8968
</span></span></code></pre></div><p><code>docker exec</code>会进入一个<strong>已经在运行的容器</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker <span class=nb>exec</span> -it 3a8357da8968 /bin/bash
</span></span></code></pre></div><ul><li>删除容器和镜像
当我们不在需要容器和镜像的时候，可以删除容器和镜像来节省内存。首先根据容器ID删除容器：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker rm 3a8357da8968
</span></span></code></pre></div><p>再根据镜像ID删除镜像。先得到镜像ID：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker images
</span></span></code></pre></div><p>我的电脑的运行结果是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
</span></span><span class=line><span class=cl>ubuntu       latest    c3d1a3432580   6 weeks ago   101MB
</span></span></code></pre></div><p>再删除镜像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker rmi c3d1a3432580
</span></span></code></pre></div><h2 id=bash-shell>Bash Shell<a hidden class=anchor aria-hidden=true href=#bash-shell>#</a></h2><h3 id=linux系统文件中的shell>Linux系统文件中的shell<a hidden class=anchor aria-hidden=true href=#linux系统文件中的shell>#</a></h3><p>Shell（壳程序）可以提供使用者操作应用程序的接口。<code>/bin/bash</code>是Linux默认的shell，Linux可用的shell记录在<code>/etc/shells</code>中，我们可以通过以下命令查看Linux可用的shells：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cat /etc/shells
</span></span></code></pre></div><p>得到的输出是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl># /etc/shells: valid login shells
</span></span><span class=line><span class=cl>/bin/sh
</span></span><span class=line><span class=cl>/usr/bin/sh
</span></span><span class=line><span class=cl>/bin/bash
</span></span><span class=line><span class=cl>/usr/bin/bash
</span></span><span class=line><span class=cl>/bin/rbash
</span></span><span class=line><span class=cl>/usr/bin/rbash
</span></span><span class=line><span class=cl>/usr/bin/dash
</span></span></code></pre></div><p>登陆Linux系统时，系统会给予一个shell，这个登陆取得的shell记录在<code>/etc/passwd</code>中，可以通过以下命令查看：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cat /etc/passwd
</span></span></code></pre></div><p>得到的输出是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>root@611b47761989:/# cat /etc/passwd
</span></span><span class=line><span class=cl>root:x:0:0:root:/root:/bin/bash
</span></span><span class=line><span class=cl>daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
</span></span><span class=line><span class=cl>......（下面省略）......
</span></span></code></pre></div><h3 id=bash-shell的功能>bash shell的功能<a hidden class=anchor aria-hidden=true href=#bash-shell的功能>#</a></h3><ul><li>记忆使用过的指令（记录的指令在<code>~/.bash_history</code>中）</li><li>命令与文件的补全（使用<code>tab</code>键，两次连按<code>tab</code>键会对匹配的命令或文件进行显示，如果只有一个与之匹配的命令或文件，则一次<code>tab</code>键会自动补全）</li><li>设置命令别名
比如要现实目录下面的所有文件 （包含隐藏文件） 及所有的文件属性，我们可以运行以下命令：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ls -al
</span></span></code></pre></div><p>但我们又是嫌弃这样写太过麻烦，我们可以对以上命令进行别名命名：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>lm</span><span class=o>=</span><span class=s1>&#39;ls -al&#39;</span>
</span></span></code></pre></div><p>那么<code>lm</code>的功能就和之前的<code>ls -al</code>功能一致了。</p><ul><li>程序化脚本（shell script）</li><li>万用字符匹配*（指令列输入指令的万用字符，<strong>不带引号</strong>）</li></ul><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td>*</td><td>代表“ 0 个到无穷多个”任意字符</td></tr><tr><td>?</td><td>代表“一定有一个”任意字符</td></tr><tr><td>[ ]</td><td>同样代表“一定有一个在括号内”的字符（非任意字符）。例如<code>[abcd]</code> 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个”</td></tr><tr><td>[ - ]</td><td>若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如<code>[0-9]</code> 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！</td></tr><tr><td>[^ ]</td><td>若中括号内的第一个字符为指数符号 （^） ，那表示“反向选择”，例如 <code>[^abc]</code> 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</td></tr></tbody></table><ul><li>与命令行相关的特殊符号</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>#</td><td>注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行</td></tr><tr><td>\</td><td>跳脱符号：将“特殊字符或万用字符”还原成一般字符</td></tr><tr><td>|</td><td>管道（pipe）：分隔两个管线命令的界定；</td></tr><tr><td>;</td><td>连续指令下达分隔符号：连续性命令的界定 （注意！与管线命令并不相同）</td></tr><tr><td>~</td><td>使用者的主文件夹</td></tr><tr><td>$</td><td>取用变量前置字符：亦即是变量之前需要加的变量取代值</td></tr><tr><td>&</td><td>工作控制 （job control）：将指令变成背景下工作</td></tr><tr><td>!</td><td>逻辑运算意义上的“非” not 的意思！</td></tr><tr><td>/</td><td>目录符号：路径分隔的符号</td></tr><tr><td>>, &#187;</td><td>数据流重导向：输出导向，分别是“取代”与“累加”</td></tr><tr><td>&lt;, &#171;</td><td>数据流重导向：输入导向</td></tr><tr><td>&rsquo; '</td><td>单引号，不具有变量置换的功能 （$ 变为纯文本）</td></tr><tr><td>" "</td><td>具有变量置换的功能！ （$ 可保留相关功能）</td></tr><tr><td></td><td>两个“ ` ”中间为可以先执行的指令，亦可使用 $（ ）</td></tr><tr><td>（ ）</td><td>在中间为子 shell 的起始与结束</td></tr><tr><td>{ }</td><td>在中间为命令区块的组合！</td></tr></tbody></table><h3 id=bash-shell的内置命令查询type>bash shell的内置命令查询：type<a hidden class=anchor aria-hidden=true href=#bash-shell的内置命令查询type>#</a></h3><p>通过<code>type</code>指令我们可以知道每个指令是否为 bash 的内置指令，此外利用<code>type</code>搜寻后面的名称时，如果后面接的名称并不能以可执行文件的状态被找到， 那么该名称是不会被显示出来的。因此我们可以也可以直接运行可执行文件来代替原命令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>type</span> -a ls
</span></span></code></pre></div><p>得到的输出为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>ls is aliased to `ls --color=auto&#39;
</span></span><span class=line><span class=cl>ls is /usr/bin/ls
</span></span><span class=line><span class=cl>ls is /bin/ls
</span></span></code></pre></div><p>因此我们也可以直接运行<code>/usr/bin/ls</code>或<code>/bin/ls</code>来代替<code>ls</code>。找指令也可以使用<code>which</code>。</p><h3 id=bash-shell中的快速编辑按钮>bash shell中的快速编辑按钮<a hidden class=anchor aria-hidden=true href=#bash-shell中的快速编辑按钮>#</a></h3><ul><li><code>ctrl-r</code>搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下<code>ctrl-r</code>会向后查找匹配项，按下<code>Enter</code>键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。</li><li><code>ctrl-w</code>删除你键入的最后一个单词，<code>ctrl-u</code>可以删除行内光标所在位置之前的内容，<code>alt-b</code>和 <code>alt-f</code>可以以单词为单位移动光标，<code>ctrl-a</code>可以将光标移至行首，<code>ctrl-e</code>可以将光标移至行尾，<code>ctrl-k</code>可以删除光标至行尾的所有内容，<code>ctrl-l</code>可以清屏。键入 <code>man readline</code> 可以查看 Bash 中的默认快捷键。内容有很多，例如 <code>alt-.</code>循环地移向前一个参数，而<code>alt-*</code>可以展开通配符。</li></ul><h3 id=shell的变量>shell的变量<a hidden class=anchor aria-hidden=true href=#shell的变量>#</a></h3><p><strong>字符串</strong>和<strong>数组</strong>是 Shell 中最常用的变量类型。
如果变量类型是<strong>数组</strong>，我们可以通过以下方式遍历所有元素：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>names</span><span class=o>=(</span><span class=s2>&#34;delkon&#34;</span> <span class=s2>&#34;ikun&#34;</span> <span class=s2>&#34;bob&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>names</span><span class=p>[@]</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># delkon ikun bob</span>
</span></span><span class=line><span class=cl><span class=c1># 但是下面的命令只能索引到第一个元素</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$names</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>delkon
</span></span></code></pre></div><p>使用<code>echo</code>命令可以读出变量
<code>echo ${variable}</code>读出variable的值(variable是<font color=#c00000>字符串</font>)
<code>echo $(command)</code>读出command的stdout
<code>echo $((expression))</code>读出表达式的值</p><h3 id=系统自带的环境变量>系统自带的环境变量<a hidden class=anchor aria-hidden=true href=#系统自带的环境变量>#</a></h3><p>利用<code>etc</code>观察系统自带环境变量如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>HOSTNAME=611b47761989 # 这部主机的主机名称
</span></span><span class=line><span class=cl>PWD=/ # 当前工作目录
</span></span><span class=line><span class=cl>HOME=/root # 当前用户的主目录
</span></span><span class=line><span class=cl>LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=00:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.avif=01;35:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:*~=00;90:*#=00;90:*.bak=00;90:*.crdownload=00;90:*.dpkg-dist=00;90:*.dpkg-new=00;90:*.dpkg-old=00;90:*.dpkg-tmp=00;90:*.old=00;90:*.orig=00;90:*.part=00;90:*.rej=00;90:*.rpmnew=00;90:*.rpmorig=00;90:*.rpmsave=00;90:*.swp=00;90:*.tmp=00;90:*.ucf-dist=00;90:*.ucf-new=00;90:*.ucf-old=00;90:
</span></span><span class=line><span class=cl>TERM=xterm # 这个终端机使用的环境是什么类型
</span></span><span class=line><span class=cl>SHLVL=1 # 当前 shell 会话的深度层级
</span></span><span class=line><span class=cl>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin # 系统搜索可执行文件的路径列表
</span></span><span class=line><span class=cl>_=/usr/bin/env # 这是最后一个执行命令的路径
</span></span></code></pre></div><p>比较重要的除了上面介绍的之外还有一个RANDOM变量，在 BASH 的环境下，这个 RANDOM 变量的内容，介于 0~32767 之间，由<code>/dev/random</code>乱数器产生。</p><h3 id=bash内的自订变量>bash内的自订变量<a hidden class=anchor aria-hidden=true href=#bash内的自订变量>#</a></h3><p>利用<code>set</code>命令观察bash内的其他变量如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>BASH=/bin/bash
</span></span><span class=line><span class=cl>......
</span></span><span class=line><span class=cl>BASH_ALIASES=()
</span></span><span class=line><span class=cl>BASH_ARGC=([0]=&#34;0&#34;)
</span></span><span class=line><span class=cl>BASH_ARGV=()
</span></span><span class=line><span class=cl>BASH_CMDS=()
</span></span><span class=line><span class=cl>BASH_LINENO=()
</span></span><span class=line><span class=cl>BASH_LOADABLES_PATH=/usr/local/lib/bash:/usr/lib/bash:/opt/local/lib/bash:/usr/pkg/lib/bash:/opt/pkg/lib/bash:.
</span></span><span class=line><span class=cl>BASH_SOURCE=()
</span></span><span class=line><span class=cl>BASH_VERSINFO=([0]=&#34;5&#34; [1]=&#34;2&#34; [2]=&#34;21&#34; [3]=&#34;1&#34; [4]=&#34;release&#34; [5]=&#34;aarch64-unknown-linux-gnu&#34;)
</span></span><span class=line><span class=cl>BASH_VERSION=&#39;5.2.21(1)-release&#39;
</span></span><span class=line><span class=cl>COLUMNS=80
</span></span><span class=line><span class=cl>DIRSTACK=()
</span></span><span class=line><span class=cl>EUID=0
</span></span><span class=line><span class=cl>GROUPS=()
</span></span><span class=line><span class=cl>HISTCONTROL=ignoredups:ignorespace
</span></span><span class=line><span class=cl>HISTFILE=/root/.bash_history
</span></span><span class=line><span class=cl>HISTFILESIZE=2000
</span></span><span class=line><span class=cl>HISTSIZE=1000
</span></span><span class=line><span class=cl>HOME=/root
</span></span><span class=line><span class=cl>HOSTNAME=611b47761989
</span></span><span class=line><span class=cl>HOSTTYPE=aarch64
</span></span><span class=line><span class=cl>IFS=$&#39; \t\n&#39;
</span></span><span class=line><span class=cl>LINES=25
</span></span><span class=line><span class=cl>......
</span></span><span class=line><span class=cl>MACHTYPE=aarch64-unknown-linux-gnu
</span></span><span class=line><span class=cl>MAILCHECK=60
</span></span><span class=line><span class=cl>OPTERR=1
</span></span><span class=line><span class=cl>OPTIND=1
</span></span><span class=line><span class=cl>OSTYPE=linux-gnu
</span></span><span class=line><span class=cl>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</span></span><span class=line><span class=cl>PIPESTATUS=([0]=&#34;0&#34;)
</span></span><span class=line><span class=cl>PPID=0
</span></span><span class=line><span class=cl>PS1=&#39;\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$ &#39;
</span></span><span class=line><span class=cl>PS2=&#39;&gt; &#39;
</span></span><span class=line><span class=cl>PS4=&#39;+ &#39;
</span></span><span class=line><span class=cl>PWD=/
</span></span><span class=line><span class=cl>SHELL=/bin/bash
</span></span><span class=line><span class=cl>SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
</span></span><span class=line><span class=cl>SHLVL=1
</span></span><span class=line><span class=cl>TERM=xterm
</span></span><span class=line><span class=cl>UID=0
</span></span><span class=line><span class=cl>_=clear
</span></span></code></pre></div><p>上面的变量有一些比较重要，我们分而述之。</p><ol><li>PS1：（提示字符的设置）
当我们每次按下<code>enter</code>键去执行某个指令后，最后要再次出现提示符时就会去读取这个变量值。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>PS1</span><span class=o>=</span><span class=s1>&#39;\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$ &#39;</span>
</span></span></code></pre></div><p>其中<code>\[\e]0;...\a\]</code>: 这是一个 ANSI 转义序列，用于在支持的终端中设置窗口的标题或图标。<code>${debian_chroot:+($debian_chroot)}</code>是条件表达式，用于在 Debian 或其他带有 chroot 环境时显示当前的 chroot 名称。<code>\u@\h</code>显示格式为 用户名@主机名，<code>\w</code>显示当前的工作目录，最后<code>\$</code>根据当前用户是否是超级用户显示不同的符号。还有一些其他比较有意思的符号，比如</p><ul><li><code>#</code> ： 下达的第几个指令。</li><li><code>\t</code> ：显示时间，为 24 小时格式的“HH:MM:SS”</li><li><code>\T</code> ：显示时间，为 12 小时格式的“HH:MM:SS”</li><li><code>\A</code> ：显示时间，为 24 小时格式的“HH:MM”</li><li><code>\@</code> ：显示时间，为 12 小时格式的“am/pm”样式</li></ul><ol start=2><li><code>$</code>：本shell的PID
我们可以运行<code>echo ${$}</code>来展示本shell的PID号码，结果如下:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>51
</span></span></code></pre></div><ol start=3><li><code>?</code>：上个执行指令的回传值
如果成功的执行上个指令， 则会回传一个 0 值，如果执行过程发生错误，就会回传非为 0 的数值。具体情形如下所示：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>cd</span> cati
</span></span></code></pre></div><p>结果为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>bash: cd: cati: No such file or directory
</span></span></code></pre></div><p>再运行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=p>?</span><span class=si>}</span>
</span></span></code></pre></div><p>结果为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>1
</span></span></code></pre></div><h3 id=自订变量和环境变量的转换>自订变量和环境变量的转换<a hidden class=anchor aria-hidden=true href=#自订变量和环境变量的转换>#</a></h3><ul><li>自订变量转成环境变量
采用<code>export</code>命令或<code>declare -x</code>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> variable
</span></span><span class=line><span class=cl><span class=nb>declare</span> -x variable
</span></span></code></pre></div><ul><li>环境变量（由自订变量转换而成的环境变量）转成自订变量</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>declare</span> <span class=o>[</span>-aixr<span class=o>]</span> variable
</span></span><span class=line><span class=cl>选项与参数：
</span></span><span class=line><span class=cl>-a  ：将后面名为 variable 的变量定义成为阵列 （array） 类型
</span></span><span class=line><span class=cl>-i  ：将后面名为 variable 的变量定义成为整数数字 （integer） 类型
</span></span><span class=line><span class=cl>-x  ：用法与 <span class=nb>export</span> 一样，就是将后面的 variable 变成环境变量；
</span></span><span class=line><span class=cl>-r  ：将变量设置成为 <span class=nb>readonly</span> 类型，该变量不可被更改内容，也不能 <span class=nb>unset</span>
</span></span></code></pre></div><p>采用<code>declare +x</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>declare</span> +x variable
</span></span></code></pre></div><h3 id=bash中与变量扩展方式>bash中与变量扩展方式<a hidden class=anchor aria-hidden=true href=#bash中与变量扩展方式>#</a></h3><ul><li><code>#</code>：从字符串开头删除与pattern匹配的最短部分，并返回剩下的字符串。也可以用来获取变量的字符长度。
语法：<code>${variable#pattern}</code>
语法：<code>${#variable}</code></li><li><code>##</code>：从字符串开头删除与pattern匹配的最长部分，并返回剩下的字符串。
语法：<code>${variable##pattern}</code></li></ul><p>具体示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>str</span><span class=o>=</span>abc.defg.hijkl.txt
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>str</span><span class=p>#*.</span><span class=si>}</span> <span class=c1># defg.hijkl.txt</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>str</span><span class=p>##*.</span><span class=si>}</span> <span class=c1># txt</span>
</span></span></code></pre></div><ul><li><code>%</code>: 从字符串末尾删除与 pattern 匹配的最短部分，并返回剩下的字符串。
语法：<code>${variable%pattern}</code></li><li><code>%%</code>：从字符串末尾删除与 pattern 匹配的最短部分，并返回剩下的字符串。
语法：<code>${variable%%pattern}</code>
具体示例如下：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>str</span><span class=p>%.*</span><span class=si>}</span> <span class=c1># abc.defg.hijkl</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>str</span><span class=p>%%.*</span><span class=si>}</span> <span class=c1># abc</span>
</span></span></code></pre></div><ul><li><code>/</code>：将变量 variable 中第一个匹配 pattern 的部分替换为 replacement。
语法：<code>${variable/pattern/replacement}</code></li><li><code>//</code>：将变量 variable 中所有匹配 pattern 的部分替换为 replacement。
语法：<code>${variable//pattern/replacement}</code>
具体示例如下：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>fname</span><span class=o>=</span>delkon-university-works
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>fname</span><span class=p>/-/_</span><span class=si>}</span> <span class=c1># delkon_university-works</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>fname</span><span class=p>//-/_</span><span class=si>}</span> <span class=c1># delkon_university_works</span>
</span></span></code></pre></div><ul><li><code>:-</code>：如果变量未定义或为空，则返回default值。
语法：<code>${variable:-default}</code></li><li><code>:=</code>：如果变量未定义或为空，则将其赋值为 default。
语法：<code>${variable:=default}</code></li><li><code>:+</code>：如果变量已定义且不为空，则返回 replacement，否则返回空字符串。
语法：<code>${variable:+replacement}</code></li><li><code>:?</code>：如果变量未定义或为空，则输出 error 消息并退出脚本。
语法：<code>${variable:?error}</code></li></ul><p>具体一些情况如下表格所示：</p><table><thead><tr><th>变量设置方式</th><th>str 没有设置</th><th>str 为空字串</th><th>str 已设置非为空字串</th></tr></thead><tbody><tr><td><code>var=${str-expr}</code></td><td><code>var=expr</code></td><td><code>var=</code></td><td><code>var=$str</code></td></tr><tr><td><code>var=${str:-expr}</code></td><td><code>var=expr</code></td><td><code>var=expr</code></td><td><code>var=$str</code></td></tr><tr><td><code>var=${str+expr}</code></td><td><code>var=</code></td><td><code>var=expr</code></td><td><code>var=expr</code></td></tr><tr><td><code>var=${str:+expr}</code></td><td><code>var=</code></td><td><code>var=</code></td><td><code>var=expr</code></td></tr><tr><td><code>var=${str=expr}</code></td><td><code>str=expr</code> <code>var=expr</code></td><td><code>str 不变 var=</code></td><td><code>str 不变</code> <code>var=$str</code></td></tr><tr><td><code>var=${str:=expr}</code></td><td><code>str=expr</code> <code>var=expr</code></td><td><code>str=expr</code> <code>var=expr</code></td><td><code>str 不变</code> <code>var=$str</code></td></tr><tr><td><code>var=${str?expr}</code></td><td><code>expr 输出至 stderr</code></td><td><code>var=</code></td><td><code>var=$str</code></td></tr><tr><td><code>var=${str:?expr}</code></td><td><code>expr 输出至 stderr</code></td><td><code>expr 输出至 stderr</code></td><td><code>var=$str</code></td></tr></tbody></table><ul><li><code>${variable:offset}</code>和<code>${variable:offset:length}</code>用来从变量中提取子字符串。</li></ul><h3 id=bash配置>bash配置<a hidden class=anchor aria-hidden=true href=#bash配置>#</a></h3><p><code>source</code>或<code>.</code>后接配置文件会立即使用该配置文件。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://fordelkon.github.io/tags/shell/>Shell</a></li><li><a href=https://fordelkon.github.io/tags/linux/>Linux</a></li><li><a href=https://fordelkon.github.io/tags/docker/>Docker</a></li></ul><nav class=paginav><a class=prev href=https://fordelkon.github.io/posts/cmd_intro_2/><span class=title>« Prev</span><br><span>使用命令行的艺术2</span>
</a><a class=next href=https://fordelkon.github.io/posts/git_intro/><span class=title>Next »</span><br><span>Git详解</span></a></nav></footer><div class=giscus_comments><script src=https://giscus.app/client.js data-repo=jesse-wei/jessewei.dev-PaperMod data-repo-id=R_kgDOJhJgPg data-category=Comments data-category-id=DIC_kwDOJhJgPs4CWei3 data-mapping=pathname data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><script async>document.querySelector("div.giscus_comments > script").setAttribute("data-theme",localStorage.getItem("pref-theme")?localStorage.getItem("pref-theme"):window.matchMedia("(prefers-color-scheme: dark)").matches?"transparent_dark":"light"),document.querySelector("#theme-toggle").addEventListener("click",()=>{let e=document.querySelector("iframe.giscus-frame");e&&e.contentWindow.postMessage({giscus:{setConfig:{theme:localStorage.getItem("pref-theme")?localStorage.getItem("pref-theme")==="dark"?"light":"transparent_dark":document.body.className.includes("dark")?"light":"transparent_dark"}}},"https://giscus.app")})</script></article></main><footer class=footer style=padding-top:18px;padding-bottom:18px><div class=social-icons style=padding-bottom:0><a style=border-bottom:none href=https://github.com/fordelkon rel=me title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a style=border-bottom:none href=https://x.com/fordelkon rel=me title=Twitter><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg>
</a><a style=border-bottom:none href=mailto:dlkong201893@gmail.com rel=me title=Email><svg viewBox="0 0 24 21" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div><span>&copy; 2025 <a href=https://fordelkon.github.io/>DL Kong</a></span>
<span>•
Powered by
<a href=https://gohugo.io/>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/>PaperMod</a>
</span><span>•
<a href=/privacy>Privacy Policy</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let b=document.querySelector("#menu-trigger"),m=document.querySelector(".menu");b.addEventListener("click",function(){m.classList.toggle("hidden")}),document.body.addEventListener("click",function(e){b.contains(e.target)||m.classList.add("hidden")})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
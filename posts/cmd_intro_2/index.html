<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用命令行的艺术2 | DL Kong</title><meta name=keywords content="Shell,Linux,Docker"><meta name=description content="熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文旨在了解命令行中的重定向功能和文件管理功能。"><meta name=author content="DL Kong"><link rel=canonical href=https://fordelkon.github.io/posts/cmd_intro_2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.c7a0847263ef81d155d535eb3508757a49b1a3680807f60ed1f64e9d4a686070.css integrity="sha256-x6CEcmPvgdFV1TXrNQh1ekmxo2gIB/YO0fZOnUpoYHA=" rel="preload stylesheet" as=style><link rel=icon href=https://fordelkon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://fordelkon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fordelkon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://fordelkon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://fordelkon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://fordelkon.github.io/posts/cmd_intro_2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><style>@media screen and (min-width:769px){.post-content input[type=checkbox]:checked~label>img{transform:scale(1.6);cursor:zoom-out;position:relative;z-index:999}.post-content img.zoomCheck{transition:transform .15s ease;z-index:999;cursor:zoom-in}}</style><link rel=stylesheet href=/css/extended/xcode.css media="(prefers-color-scheme: light)"><link rel=stylesheet href=/css/extended/monokai.css media="(prefers-color-scheme: dark)"><script async src="https://www.googletagmanager.com/gtag/js?id=G-Q603T56FWT"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Q603T56FWT")}</script><meta property="og:url" content="https://fordelkon.github.io/posts/cmd_intro_2/"><meta property="og:site_name" content="DL Kong"><meta property="og:title" content="使用命令行的艺术2"><meta property="og:description" content="熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文旨在了解命令行中的重定向功能和文件管理功能。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-25T13:50:00+09:00"><meta property="article:modified_time" content="2025-08-25T13:50:00+09:00"><meta property="article:tag" content="Shell"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Docker"><meta property="og:image" content="https://fordelkon.github.io/img/cmdart.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://fordelkon.github.io/img/cmdart.png"><meta name=twitter:title content="使用命令行的艺术2"><meta name=twitter:description content="熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文旨在了解命令行中的重定向功能和文件管理功能。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fordelkon.github.io/posts/"},{"@type":"ListItem","position":2,"name":"使用命令行的艺术2","item":"https://fordelkon.github.io/posts/cmd_intro_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用命令行的艺术2","name":"使用命令行的艺术2","description":"熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文旨在了解命令行中的重定向功能和文件管理功能。\n","keywords":["Shell","Linux","Docker"],"articleBody":"熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文旨在了解命令行中的重定向功能和文件管理功能。\n重定向（redirect） 输入输出重定向 \u003e覆盖，\u003e\u003e累加\n标准输入　(stdin) ：代码为0，使用\u003c或\u003c\u003c； 标准输出　(stdout)：代码为1，使用\u003e或\u003e\u003e； 标准错误输出(stderr)：代码为2，使用2\u003e或2\u003e\u003e； 2\u003e\u00261来将2\u003e转到1\u003e去，而1\u003e\u00262来将1\u003e转到2\u003e去。（感觉像是首要定性，先分配好stdout和stderr的走向） 2\u003e\u00261:\ntype list \u003e list # bash: type: list: not found cat list type list \u003e list 2\u003e\u00261 cat list # bash: type: list: not found type cd \u003e list 2\u003e\u00261 # cd is a shell builtin 1\u003e\u00262:\necho \"error message\" 1\u003e\u00262 # error message echo \"error message\" 2\u003e /dev/null 1\u003e\u00262 管道重定向 |：仅能处理经由前面一个指令传来的正确信息，也就是 stdout 的信息，对于 stderr并没有直接处理的能力；必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。\n基础正则表达式(grep中的’pattern’格式) RE 字符 意义与范例 ^word 意义：待搜索的字符串(word)在行首！ 范例：搜索行首为 # 开始的那一行，并列出行号\ngrep -n '^#' regular_express.txt word$ 意义：待搜索的字符串(word)在行尾！ 范例：将行尾为 ! 的那一行打印出来，并列出行号\ngrep -n '!$' regular_express.txt . 意义：代表一定有一个任意字符的字符！ 范例：搜索的字符串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间『一定』仅有一个字符，而空白字符也是字符！\ngrep -n 'e.e' regular_express.txt \\ 意义：跳脱字符，将特殊符号的特殊意义去除！ 范例：搜索含有单引号 ’ 的那一行！\ngrep -n \\' regular_express.txt * 意义：重复零个到无穷多个的前一个 RE 字符 范例：找出含有 (es) (ess) (esss) 等等的字符串，注意，因为 * 可以是 0 个，所以 es 也是符合带搜索字符串。另外，因为 * 为重复前一个 RE 字符的符号， 因此，在 * 之前必须要紧接着一个 RE 字符喔！例如任意字符则为 .* ！\ngrep -n 'ess*' regular_express.txt [list] 意义：字符集合的 RE 字符，里面列出想要截取的字符！ 范例：搜索含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在[]当中谨代表一个待搜索的字符， 例如a[afl]y代表搜索的字符串可以是 aay, afy, aly 即 [afl]代表 a 或 f 或 l 的意思！\ngrep -n 'g[ld]' regular_express.txt [n1-n2] 意义：字符集合的 RE 字符，里面列出想要截取的字符范围！ 范例：搜索含有任意数字的那一行！需特别留意，在字符集合 [] 中的减号 - 是有特殊意义的，他代表两个字符之间的所有连续字符！但这个连续与否与 ASCII 编码有关，因此，你的编码需要设置正确(在 bash 当中，需要确定 LANG 与 LANGUAGE 的变量是否正确！) 例如所有大写字符则为 [A-Z]\ngrep -n '[A-Z]' regular_express.txt [^list] 意义：字符集合的 RE 字符，里面列出不要的字符串或范围！ 范例：搜索的字符串可以是 (oog) (ood) 但不能是 (oot) ，那个 ^ 在 [] 内时，代表的意义是『反向选择』的意思。 例如，我不要大写字符，则为[^A-Z]。但是，需要特别注意的是，如果以 grep -n [^A-Z] regular_express.txt 来搜索，却发现该文件内的所有行都被列出，为什么？因为这个 [^A-Z] 是非大写字符的意思， 因为每一行均有非大写字符，例如第一行的 “Open Source” 就有 p,e,n,o…. 等等的小写字\ngrep -n 'oo[^t]' regular_express.txt \\{n,m\\} 意义：连续 n 到 m 个的前一个 RE 字符 意义：若为 \\{n\\} 则是连续 n 个的前一个 RE 字符， 意义：若是 \\{n,\\} 则是连续 n 个以上的前一个 RE 字符！ 范例：在 g 与 g 之间有 2 个到 3 个的 o 存在的字符串，亦即 (goog)(gooog)\ngrep -n 'go\\{2,3\\}g' regular_express.txt 常用的管道命令grep:\ngrep [-acinv] [--color=auto] 'pattern' filename 选项与参数： -i ：忽略大小写的不同，所以大小写视为相同 -o ：只输出匹配的部分而不是整行 -v ：反向选择，亦即显示出没有匹配'pattern'的字符串内容的那些行！ -A ：显示匹配行+匹配行行后的几行(after) -B ：显示匹配行+匹配行行前的几行(before) -C ：显示匹配行+匹配行行前后的几行(context) --color=auto ：可以将找到的关键字部分加上颜色的显示喔！ # 将有出现 root 的那一行就取出来； last | grep 'root' # 只要没有 root 的就取出！ last | grep -v 'root' # # wtmp begins Tue Mar 11 22:41:15 2025 # 在 last 的输出消息中，只要有 root 就取出，并且仅取第一栏 last | grep -v 'root' | cut -d ' ' -f 1 # # wtmp # 在取出 root 之后，利用上个指令 cut 的处理，就能够仅取得第一栏啰！ # 神奇的是，如果加上 --color=auto 的选项，找到的关键字部分会用特殊颜色显示喔！ 常用的管道命令awk：\nawk [-F] [delimiter] 'pattern {action}' filename 选项与参数： -F ：制定分隔符，默认为空格或制表符 # 列出当前GPU下所有的python进程号 nvidia-smi | grep python | awk '{print $5}' # 18108 # 18737 # 19383 # 19565 # 19725 # 19799 # 19859 # 19977 # 20550 # 20733 awk 'FS=\":\" { print $1, $3 }' /etc/passwd # root:x:0:0:root:/root:/bin/bash # daemon 1 # bin 2 # sys 3 # sync 4 # games 5 # man 6 # ...... awk动作中的内置变量，动作中的关键字是print：\n$0：当前行的所有内容。 $1, $2, $3,…：每行的各个字段，从第一个字段开始。 NR：当前行号。 NF：当前行的字段数。 FS：字段分隔符，默认为空格或制表符。 OFS：输出字段分隔符，默认为空格。 RS：行分隔符，默认为换行符。 ORS：输出行分隔符，默认为换行符。 常用管道命令sed：\nsed [-nefr] [action] 选项与参数： -n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。 但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行(或者动作)才会被列出来。 -e ：直接在指令列模式上进行 sed 的动作编辑； -f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作； -r ：sed 的动作支持的是延伸型正规表示法的语法。(缺省是基础正规表示法语法) -i ：直接修改读取的文件内容，而不是由屏幕输出。 动作说明： [n1[,n2]]function n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作 是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』 function 有底下这些咚咚： a ：添加， a 的后面可以接字符串，而这些字符串会在新的一行出现(目前的下一行)～ c ：取代， c 的后面可以接字符串，这些字符串可以取代 n1,n2 之间的行！ d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚； i ：插入， i 的后面可以接字符串，而这些字符串会在新的一行出现(目前的上一行)； p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运作～ s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！ 例如 1,20s/old/new/g 就是啦！（类似vim命令行替换操作） nl /etc/passwd | sed '2,5d' # 将 /etc/passwd 的内容列出并且打印行号，同时，请将第 2~5 行删除！ nl /etc/passwd | sed '2a drink tea' # 在第二行后(亦即是加在第三行)加上『drink tea』字样！ nl /etc/passwd | sed '2i drink tea' # 在第二行前(亦即是加在第三行)加上『drink tea』字样！ nl /etc/passwd | sed '2,5c No 2-5 number' # 将第2-5行的内容取代成为『No 2-5 number』 nl /etc/passwd | sed -n '5,7p' # 列出 /etc/passwd 文件内的第 5-7 行 cat /etc/man_db.conf | grep 'MAN'| sed 's/#.*$//g' 删除掉注解之后的数据！ xargs + |：xargs可以读入stdin的数据，并且以空格或换行字符作为分辨，将stdin的数据分隔成为arguments。\nxargs搭配｜更加美味😋：\ncommand1 | xargs [-ndI{}] command2 选项与参数： -n ：后面接次数，每次command2指令运行时，要使用几个参数的意思。 -d ：指定定界符，默认是空格或换行符。delimiter -I{}：指定替换字符串。每次读取一行数据并将{}替换为该行数据。 cat hosts # delkon # study # flypig # ikun # daniel cat hosts | xargs -I{} echo root@{} # root@delkon # root@study # root@flypig # root@ikun # root@daniel cat hosts | xargs -n 2 echo # delkon study # flypig ikun # daniel ls # dataloaders.py lr_scheduler.py torch_utils.py find . -name '*.py' | xargs grep 'matplotlib' # ./dataloaders.py:import matplotlib.pyplot as plt # ./dataloaders.py:from matplotlib import rcParams 文件管理 ls -l展示文件属性 ls -l # total 64 # lrwxrwxrwx 1 root root 7 Apr 22 2024 bin -\u003e usr/bin # drwxr-xr-x 2 root root 4096 Apr 22 2024 boot # drwxr-xr-x 5 root root 360 Mar 13 15:38 dev # drwxr-xr-x 1 root root 4096 Mar 12 20:33 etc # drwxr-xr-x 1 root root 4096 Jan 27 10:19 home # lrwxrwxrwx 1 root root 7 Apr 22 2024 lib -\u003e usr/lib # drwxr-xr-x 2 root root 4096 Jan 27 10:12 media # drwxr-xr-x 2 root root 4096 Jan 27 10:12 mnt # drwxr-xr-x 2 root root 4096 Jan 27 10:12 opt # dr-xr-xr-x 213 root root 0 Mar 13 15:38 proc # drwx------ 1 root root 4096 Mar 13 16:25 root # drwxr-xr-x 4 root root 4096 Jan 27 10:19 run # lrwxrwxrwx 1 root root 8 Apr 22 2024 sbin -\u003e usr/sbin # drwxr-xr-x 2 root root 4096 Jan 27 10:12 srv # dr-xr-xr-x 11 root root 0 Mar 13 15:51 sys # drwxrwxrwt 1 root root 4096 Mar 12 17:30 tmp # drwxr-xr-x 1 root root 4096 Jan 27 10:12 usr # drwxr-xr-x 1 root root 4096 Jan 27 10:19 var 第一列总共10位\n第一位表示文件类型，可以有以下几种字母表示： -：普通文件 d：目录 l：符号连接 b：块设备文件 c：字符设备文件 s：套接字 p：命名管道 剩下9位分为3组，每组3位分别有以下权限r（可读）w（可写）x（可执行） 2-4位：文件属主（owner）的权限 5-7位：同组用户（group）的权限 8-10位：其他用户（others）的权限 第二列表示硬链接数，硬链接是指向同一个文件的多个文件名。对于目录，这个数字表示目录下的子目录数量加 2（当前目录 . 和父目录 ..）。\n第三列和第四列分别表示文件属主和文件属组。\n第五列表示文件大小，以字节为单位。如果文件是符号链接，大小为链接目标的路径长度（如 bin -\u003e usr/bin 中，大小为 7 是因为 usr/bin 有 7 个字符）。如果是目录，则一般固定为 4096 字节。\n第六列第七列第八列表示最后修改时间。\n第九列表示文件名，如果是符号链接（如 bin -\u003e usr/bin），则后面会显示链接的目标。\nln进行符号链接和硬链接 ln [-sf] src dst 选项与参数： -s ：创建符号链接。 -f ：强制创建链接文件，覆盖已经存在的目标文件。 ls # Python hosts ln hosts hardlink_hosts ls # Python hardlink_hosts hosts ln -s hosts symboliclink_hosts ls # Python hardlink_hosts hosts symboliclink_hosts ls -l # drwxr-xr-x 2 root root 4096 Mar 13 16:25 Python # -rw-r--r-- 2 root root 32 Mar 13 16:09 hardlink_hosts # -rw-r--r-- 2 root root 32 Mar 13 16:09 hosts # lrwxrwxrwx 1 root root 5 Mar 13 17:25 symboliclink_hosts -\u003e hosts cat hosts cat hardlink_hosts cat symboliclink_hosts # delkon # study # flypig # ikun # daniel 特性 硬链接（Hard Link） 符号链接（Symbolic Link） 指向 指向文件的物理数据块 指向文件的路径 文件大小 与原文件相同 符号链接本身只占用少量空间（保存路径） 文件系统限制 只能在同一文件系统上创建 可以跨文件系统创建 删除效果 删除硬链接不会删除文件数据，除非所有硬链接被删除 删除符号链接不会影响原文件 适用场景 文件备份，防止意外删除 快捷访问其他文件、跨目录、文件系统使用 硬盘 硬盘的使用：硬盘分区-\u003e硬盘格式化（format)-\u003e文件系统的挂载\n硬盘分区 /dev/sd[a-p][1-128]：为分区后的实体硬盘分配的硬盘文件名； /dev/vd[a-d][1-128]：为分区后的虚拟硬盘分配的硬盘文件名。 本系统下的所有磁盘与磁盘内的分割信息使用lsblk(list block device)查看\nlsblk [-dfimpt] [device] 选项与参数： -d ：仅列出磁盘本身，并不会列出该磁盘的分割数据 -f ：同时列出该磁盘内的文件系统名称 -i ：使用 ASCII 的线段输出，不要使用复杂的编码 (再某些环境下很有用) -m ：同时输出该设备在 /dev 底下的权限数据 (rwx 的数据) -p ：列出该设备的完整文件名！而不是仅列出最后的名字而已。 -t ：列出该磁盘设备的详细数据，包括磁盘队列机制、预读写的数据量大小等 lsblk # NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS # nbd0 43:0 0 0B 0 disk # nbd1 43:32 0 0B 0 disk # nbd2 43:64 0 0B 0 disk # nbd3 43:96 0 0B 0 disk # nbd4 43:128 0 0B 0 disk # nbd5 43:160 0 0B 0 disk # nbd6 43:192 0 0B 0 disk # nbd7 43:224 0 0B 0 disk # vda 254:0 0 59.6G 0 disk # `-vda1 254:1 0 59.6G 0 part /etc/hosts # /etc/hostname # /etc/resolv.conf # vdb 254:16 0 535.2M 1 disk # nbd8 43:256 0 0B 0 disk # nbd9 43:288 0 0B 0 disk # nbd10 43:320 0 0B 0 disk # nbd11 43:352 0 0B 0 disk # nbd12 43:384 0 0B 0 disk # nbd13 43:416 0 0B 0 disk # nbd14 43:448 0 0B 0 disk # nbd15 43:480 0 0B 0 disk NAME：就是设备的文件名！会省略 /dev 等前导目录！ MAJ:MIN：其实核心认识的设备都是透过这两个代码来熟悉的！分别是主要：次要设备代码！ RM：是否为可卸载设备 (removable device)，如光盘、USB 磁盘等等 SIZE：当然就是容量啰！ RO：是否为唯读设备的意思 TYPE：是磁盘 (disk)、分区 (partition) 还是唯读内存 (rom) 等输出 MOUTPOINT：就是挂载点！ 硬盘格式化 分割完毕后自然就是要进行文件系统的格式化，我们使用mkfs(make filesystem)来进行分区后硬盘的格式化。\nmkfs[tab][tab] # mkfs mkfs.cramfs mkfs.ext3 mkfs.minix # mkfs.bfs mkfs.ext2 mkfs.ext4 文件系统挂载 我们首先要明确，挂载点是目录，这个目录是进入硬盘分区（文件系统）的入口。同时挂载之前我们还应该确定一些事：\n单一文件系统不应该被重复挂载在不同的挂载点(目录)中； 单一目录不应该重复挂载多个文件系统； 要作为挂载点的目录，理论上应该都是空目录才是。 挂载使用的命令是mount，具体如下：\nmount -a mount [-l] mount [-t 文件系统] LABEL='' 挂载点 mount [-t 文件系统] UUID='' 挂载点 # 鸟哥近期建议用这种方式喔！ mount [-t 文件系统] 设备文件名 挂载点 选项与参数： -a ：依照设置档 [/etc/fstab](https://muicoder.github.io/linux_basic/0230filesystem.html#fstab)的数据将所有未挂载的磁盘都挂载上来 -l ：单纯的输入 mount 会显示目前挂载的信息。加上 -l 可增列 Label 名称！ -t ：可以加上文件系统种类来指定欲挂载的类型。常见的 Linux 支持类型有：xfs, ext3, ext4, reiserfs, vfat, iso9660(光盘格式), nfs, cifs, smbfs (后三种为网络文件系统类型) 设备文件的卸载 umount [-fn] 设备文件名或挂载点 选项与参数： -f ：强制卸载！可用在类似网络文件系统 (NFS) 无法读取到的情况下； -l ：立刻卸载文件系统，比 -f 还强！ -n ：不更新 /etc/mtab 情况下卸载。 硬盘状态 df（disk free）用于显示磁盘的整体使用情况。\ndf [-akmhHTi] [目录或文件名] 选项与参数： -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统； -k ：以 KBytes 的容量显示各文件系统； -m ：以 MBytes 的容量显示各文件系统； -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； -H ：以 M=1000K 取代 M=1024K 的进位方式； -T ：连同该 partition 的 filesystem 名称 (例如 xfs) 也列出； -i ：不用磁盘容量，而以 inode 的数量来显示 df -h # Filesystem Size Used Avail Use% Mounted on # overlay 59G 1.3G 55G 3% / # tmpfs 64M 0 64M 0% /dev # shm 64M 0 64M 0% /dev/shm # /dev/vda1 59G 1.3G 55G 3% /etc/hosts # tmpfs 2.0G 0 2.0G 0% /proc/scsi # tmpfs 2.0G 0 2.0G 0% /sys/firmware du（disk usage）用于查看文件和目录的磁盘使用情况。\ndu [-ahskm] 文件或目录名称 -a ：列出所有的文件与目录容量，因为缺省仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； Linux文件 文件属性和权限的更改 • chown 用于更改文件或目录的所有者和组。要注意的是， 用户必须是已经存在系统中的帐号，也就是在/etc/passwd 这个文件中有纪录的用户名才能改变。可更改的组名也记录在/etc/group中。\nchown [-R] 用户 文件或目录 chown [-R] 用户:组 文件或目录 选项与参数： -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都变更 ll # total 32 # drwxr-xr-x 2 ubuntu ubuntu 4096 Mar 14 11:24 ./ # drwxr-x--- 1 ubuntu ubuntu 4096 Mar 14 11:24 ../ # -rw-r--r-- 1 ubuntu ubuntu 8733 Mar 13 16:25 dataloaders.py # -rw-r--r-- 1 ubuntu ubuntu 4231 Mar 13 16:24 lr_scheduler.py # -rw-r--r-- 1 ubuntu ubuntu 4043 Mar 13 16:24 torch_utils.py chown -R root:root ./ ll # total 32 # drwxr-xr-x 2 root root 4096 Mar 14 11:27 ./ # drwxr-x--- 1 ubuntu ubuntu 4096 Mar 14 11:24 ../ # -rw-r--r-- 1 root root 8748 Mar 14 11:27 dataloaders.py # -rw-r--r-- 1 root root 4231 Mar 13 16:24 lr_scheduler.py # -rw-r--r-- 1 root root 4043 Mar 13 16:24 torch_utils.py • chmod 用于更改文件或目录的权限，控制读、写、执行权限。\n数字 chmod [-R] xyz 文件或目录 选项与参数： xyz : 就是刚刚提到的数字类型的权限属性，为 r(4)w(2)x(1) 属性数值的相加。 -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更 ll ./dataloader.py # -rw-r--r-- 1 root root 8748 Mar 14 11:27 dataloaders.py chmod a+w ./dataloader.py ll ./dataloader.py # -rw-rw-rw- 1 root root 8748 Mar 14 11:27 dataloaders.py chmod u=rw.go=r ./dataloader.py ll ./dataloader.py # -rw-r--r-- 1 root root 8748 Mar 14 11:27 ./dataloaders.py 符号 chmod u (user)\ng (group)\no (others)\na (all) +(加入) -(除去) =(设置) r w x 文件或目录 文件搜索 find [PATH] [option] [action] 选项与参数： 与文件权限及名称有关的参数： -name filename：搜索文件名称为 filename 的文件； -size [+-]SIZE：搜索比 SIZE 还要大(+)或小(-)的文件。这个 SIZE 的规格有：c: 代表 byte， k: 代表 1024bytes。所以，要找比 50KB还要大的文件，就是『 -size +50k 』 -type TYPE ：搜索文件的类型为 TYPE 的，类型主要有：一般正规文件 (f), 设备文件 (b, c), 目录 (d), 链接档 (l), socket (s), 及 FIFO (p) 等属性。 ll /Python # total 32 # drwxr-xr-x 2 root root 4096 Mar 14 11:40 ./ # drwxr-x--- 1 ubuntu ubuntu 4096 Mar 14 12:50 ../ # -rw-r--r-- 1 root root 8748 Mar 14 11:27 dataloaders.py # -rw-r--r-- 1 root root 4231 Mar 13 16:24 lr_scheduler.py # -rw-r--r-- 1 root root 4043 Mar 13 16:24 torch_utils.py find Python/ -name '*.py' # Python/torch_utils.py # Python/lr_scheduler.py # Python/dataloaders.py find Python/ -size -20k # Python/ # Python/torch_utils.py # Python/lr_scheduler.py # Python/dataloaders.py find Python/ -type f # Python/torch_utils.py # Python/lr_scheduler.py # Python/dataloaders.py ","wordCount":"1734","inLanguage":"en","image":"https://fordelkon.github.io/img/cmdart.png","datePublished":"2025-08-25T13:50:00+09:00","dateModified":"2025-08-25T13:50:00+09:00","author":{"@type":"Person","name":"DL Kong"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://fordelkon.github.io/posts/cmd_intro_2/"},"publisher":{"@type":"Organization","name":"DL Kong","logo":{"@type":"ImageObject","url":"https://fordelkon.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fordelkon.github.io/ accesskey=h title="DL Kong (Alt + H)"><img src=https://fordelkon.github.io/logo_filled_outlined_6.png alt="Site icon in header" aria-label=logo height=35>DL Kong</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><button id=menu-trigger aria-haspopup=menu aria-label="Menu Button">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><ul class="menu hidden"><li><a href=https://fordelkon.github.io/about/ title=About><span>About</span></a></li><li><a href=https://fordelkon.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://fordelkon.github.io/teaching/ title=Teaching><span>Teaching</span></a></li><li><a href=https://fordelkon.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fordelkon.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://fordelkon.github.io/posts/>Posts</a></div><h1 class=post-title>使用命令行的艺术2</h1><div class=post-meta><span title='2025-08-25 13:50:00 +0900 +0900'>August 8, 25000</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;DL Kong</div></header><div class="toc side left"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#重定向redirect>重定向（redirect）</a><ul><li><a href=#输入输出重定向>输入输出重定向</a></li><li><a href=#管道重定向>管道重定向</a></li><li><a href=#基础正则表达式grep中的pattern格式>基础正则表达式(grep中的&rsquo;pattern&rsquo;格式)</a></li></ul></li><li><a href=#文件管理>文件管理</a><ul><li><a href=#ls--l展示文件属性><code>ls -l</code>展示文件属性</a></li><li><a href=#ln进行符号链接和硬链接><code>ln</code>进行符号链接和硬链接</a></li><li><a href=#硬盘>硬盘</a><ul><li><a href=#硬盘分区>硬盘分区</a></li><li><a href=#硬盘格式化>硬盘格式化</a></li><li><a href=#文件系统挂载>文件系统挂载</a></li><li><a href=#设备文件的卸载>设备文件的卸载</a></li><li><a href=#硬盘状态>硬盘状态</a></li></ul></li><li><a href=#linux文件>Linux文件</a><ul><li><a href=#文件属性和权限的更改>文件属性和权限的更改</a></li><li><a href=#文件搜索>文件搜索</a></li></ul></li></ul></li></ul></nav></div></details></div><div class=post-content><p>熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文旨在了解命令行中的重定向功能和文件管理功能。</p><h2 id=重定向redirect>重定向（redirect）<a hidden class=anchor aria-hidden=true href=#重定向redirect>#</a></h2><h3 id=输入输出重定向>输入输出重定向<a hidden class=anchor aria-hidden=true href=#输入输出重定向>#</a></h3><p><code>></code>覆盖，<code>>></code>累加</p><ol><li>标准输入　　(stdin) ：代码为<code>0</code>，使用<code>&lt;</code>或<code>&lt;&lt;</code>；</li><li>标准输出　　(stdout)：代码为<code>1</code>，使用<code>></code>或<code>>></code>；</li><li>标准错误输出(stderr)：代码为<code>2</code>，使用<code>2></code>或<code>2>></code>；</li></ol><p> <code>2>&amp;1</code>来将<code>2></code>转到<code>1></code>去，而<code>1>&amp;2</code>来将<code>1></code>转到<code>2></code>去。（感觉像是首要定性，先分配好stdout和stderr的走向）
 <code>2>&amp;1</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>type</span> list &gt; list 
</span></span><span class=line><span class=cl><span class=c1># bash: type: list: not found</span>
</span></span><span class=line><span class=cl>cat list
</span></span><span class=line><span class=cl><span class=nb>type</span> list &gt; list 2&gt;<span class=p>&amp;</span><span class=m>1</span>
</span></span><span class=line><span class=cl>cat list
</span></span><span class=line><span class=cl><span class=c1># bash: type: list: not found </span>
</span></span><span class=line><span class=cl><span class=nb>type</span> <span class=nb>cd</span> &gt; list 2&gt;<span class=p>&amp;</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=c1># cd is a shell builtin</span>
</span></span></code></pre></div><p><code>1>&amp;2</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;error message&#34;</span> 1&gt;<span class=p>&amp;</span><span class=m>2</span>
</span></span><span class=line><span class=cl><span class=c1># error message</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;error message&#34;</span> 2&gt; /dev/null 1&gt;<span class=p>&amp;</span><span class=m>2</span>
</span></span></code></pre></div><h3 id=管道重定向>管道重定向<a hidden class=anchor aria-hidden=true href=#管道重定向>#</a></h3><p><code>|</code>：仅能处理经由前面一个指令传来的正确信息，也就是 stdout 的信息，对于 stderr并没有直接处理的能力；必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。</p><h3 id=基础正则表达式grep中的pattern格式>基础正则表达式(grep中的&rsquo;pattern&rsquo;格式)<a hidden class=anchor aria-hidden=true href=#基础正则表达式grep中的pattern格式>#</a></h3><table><thead><tr><th>RE 字符</th><th>意义与范例</th></tr></thead><tbody><tr><td><code>^word</code></td><td>意义：待搜索的字符串(word)在行首！<br>范例：搜索行首为 # 开始的那一行，并列出行号<br><code>grep -n '^#' regular_express.txt</code></td></tr><tr><td><code>word$</code></td><td>意义：待搜索的字符串(word)在行尾！<br>范例：将行尾为 ! 的那一行打印出来，并列出行号<br><code>grep -n '!$' regular_express.txt</code></td></tr><tr><td><code>.</code></td><td>意义：代表<code>一定有一个任意字符</code>的字符！<br>范例：搜索的字符串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间『一定』仅有一个字符，而空白字符也是字符！<br><code>grep -n 'e.e' regular_express.txt</code></td></tr><tr><td><code>\</code></td><td>意义：跳脱字符，将特殊符号的特殊意义去除！<br>范例：搜索含有单引号 &rsquo; 的那一行！<br><code>grep -n \' regular_express.txt</code></td></tr><tr><td><code>*</code></td><td>意义：重复零个到无穷多个的前一个 RE 字符<br>范例：找出含有 (es) (ess) (esss) 等等的字符串，注意，因为 <code>*</code> 可以是 0 个，所以 es 也是符合带搜索字符串。另外，因为 <code>*</code> 为重复前一个 RE 字符的符号， 因此，在 <code>*</code> 之前必须要紧接着一个 RE 字符喔！例如任意字符则为 <code>.*</code> ！<br><code>grep -n 'ess*' regular_express.txt</code></td></tr><tr><td><code>[list]</code></td><td>意义：字符集合的 RE 字符，里面列出想要截取的字符！<br>范例：搜索含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在<code>[]</code>当中谨代表一个待搜索的字符， 例如<code>a[afl]y</code>代表搜索的字符串可以是 aay, afy, aly 即 <code>[afl]</code>代表 a 或 f 或 l 的意思！<br><code>grep -n 'g[ld]' regular_express.txt</code></td></tr><tr><td><code>[n1-n2]</code></td><td>意义：字符集合的 RE 字符，里面列出想要截取的字符范围！<br>范例：搜索含有任意数字的那一行！需特别留意，在字符集合 <code>[]</code> 中的减号 - 是有特殊意义的，他代表两个字符之间的所有连续字符！但这个连续与否与 ASCII 编码有关，因此，你的编码需要设置正确(在 bash 当中，需要确定 LANG 与 LANGUAGE 的变量是否正确！) 例如所有大写字符则为 <code>[A-Z]</code><br><code>grep -n '[A-Z]' regular_express.txt</code></td></tr><tr><td><code>[^list]</code></td><td>意义：字符集合的 RE 字符，里面列出不要的字符串或范围！<br>范例：搜索的字符串可以是 (oog) (ood) 但不能是 (oot) ，那个 ^ 在 <code>[]</code> 内时，代表的意义是『反向选择』的意思。 例如，我不要大写字符，则为<code>[^A-Z]</code>。但是，需要特别注意的是，如果以 <code>grep -n [^A-Z] regular_express.txt</code> 来搜索，却发现该文件内的所有行都被列出，为什么？因为这个 <code>[^A-Z]</code> 是非大写字符的意思， 因为每一行均有非大写字符，例如第一行的 &ldquo;Open Source&rdquo; 就有 p,e,n,o&mldr;. 等等的小写字<br><code>grep -n 'oo[^t]' regular_express.txt</code></td></tr><tr><td><code>\{n,m\}</code></td><td>意义：连续 n 到 m 个的前一个 RE 字符<br>意义：若为 <code>\{n\}</code> 则是连续 n 个的前一个 RE 字符，<br>意义：若是 <code>\{n,\}</code> 则是连续 n 个以上的前一个 RE 字符！ 范例：在 g 与 g 之间有 2 个到 3 个的 o 存在的字符串，亦即 (goog)(gooog)<br><code>grep -n 'go\{2,3\}g' regular_express.txt</code></td></tr></tbody></table><p>常用的管道命令<code>grep</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>grep <span class=o>[</span>-acinv<span class=o>]</span> <span class=o>[</span>--color<span class=o>=</span>auto<span class=o>]</span> <span class=s1>&#39;pattern&#39;</span> filename
</span></span><span class=line><span class=cl>选项与参数：
</span></span><span class=line><span class=cl>-i ：忽略大小写的不同，所以大小写视为相同
</span></span><span class=line><span class=cl>-o ：只输出匹配的部分而不是整行
</span></span><span class=line><span class=cl>-v ：反向选择，亦即显示出没有匹配<span class=s1>&#39;pattern&#39;</span>的字符串内容的那些行！
</span></span><span class=line><span class=cl>-A ：显示匹配行+匹配行行后的几行<span class=o>(</span>after<span class=o>)</span>
</span></span><span class=line><span class=cl>-B ：显示匹配行+匹配行行前的几行<span class=o>(</span>before<span class=o>)</span>
</span></span><span class=line><span class=cl>-C ：显示匹配行+匹配行行前后的几行<span class=o>(</span>context<span class=o>)</span>
</span></span><span class=line><span class=cl>--color<span class=o>=</span>auto ：可以将找到的关键字部分加上颜色的显示喔！
</span></span><span class=line><span class=cl><span class=c1># 将有出现 root 的那一行就取出来；</span>
</span></span><span class=line><span class=cl>last <span class=p>|</span> grep <span class=s1>&#39;root&#39;</span>
</span></span><span class=line><span class=cl><span class=c1># 只要没有 root 的就取出！</span>
</span></span><span class=line><span class=cl>last <span class=p>|</span> grep -v <span class=s1>&#39;root&#39;</span>
</span></span><span class=line><span class=cl><span class=c1># </span>
</span></span><span class=line><span class=cl><span class=c1># wtmp begins Tue Mar 11 22:41:15 2025</span>
</span></span><span class=line><span class=cl><span class=c1># 在 last 的输出消息中，只要有 root 就取出，并且仅取第一栏</span>
</span></span><span class=line><span class=cl>last <span class=p>|</span> grep -v <span class=s1>&#39;root&#39;</span> <span class=p>|</span> cut -d <span class=s1>&#39; &#39;</span> -f <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=c1># </span>
</span></span><span class=line><span class=cl><span class=c1># wtmp</span>
</span></span><span class=line><span class=cl><span class=c1># 在取出 root 之后，利用上个指令 cut 的处理，就能够仅取得第一栏啰！</span>
</span></span><span class=line><span class=cl><span class=c1># 神奇的是，如果加上 --color=auto 的选项，找到的关键字部分会用特殊颜色显示喔！</span>
</span></span></code></pre></div><p>常用的管道命令<code>awk</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>awk <span class=o>[</span>-F<span class=o>]</span> <span class=o>[</span>delimiter<span class=o>]</span> <span class=s1>&#39;pattern {action}&#39;</span> filename
</span></span><span class=line><span class=cl>选项与参数：
</span></span><span class=line><span class=cl>-F ：制定分隔符，默认为空格或制表符
</span></span><span class=line><span class=cl><span class=c1># 列出当前GPU下所有的python进程号</span>
</span></span><span class=line><span class=cl>nvidia-smi <span class=p>|</span> grep python <span class=p>|</span> awk <span class=s1>&#39;{print $5}&#39;</span>
</span></span><span class=line><span class=cl><span class=c1># 18108</span>
</span></span><span class=line><span class=cl><span class=c1># 18737</span>
</span></span><span class=line><span class=cl><span class=c1># 19383</span>
</span></span><span class=line><span class=cl><span class=c1># 19565</span>
</span></span><span class=line><span class=cl><span class=c1># 19725</span>
</span></span><span class=line><span class=cl><span class=c1># 19799</span>
</span></span><span class=line><span class=cl><span class=c1># 19859</span>
</span></span><span class=line><span class=cl><span class=c1># 19977</span>
</span></span><span class=line><span class=cl><span class=c1># 20550</span>
</span></span><span class=line><span class=cl><span class=c1># 20733</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>awk <span class=s1>&#39;FS=&#34;:&#34;  { print $1, $3 }&#39;</span> /etc/passwd
</span></span><span class=line><span class=cl><span class=c1># root:x:0:0:root:/root:/bin/bash </span>
</span></span><span class=line><span class=cl><span class=c1># daemon 1</span>
</span></span><span class=line><span class=cl><span class=c1># bin 2</span>
</span></span><span class=line><span class=cl><span class=c1># sys 3</span>
</span></span><span class=line><span class=cl><span class=c1># sync 4</span>
</span></span><span class=line><span class=cl><span class=c1># games 5</span>
</span></span><span class=line><span class=cl><span class=c1># man 6</span>
</span></span><span class=line><span class=cl><span class=c1># ......</span>
</span></span></code></pre></div><p><code>awk</code>动作中的<strong>内置变量</strong>，动作中的关键字是<code>print</code>：</p><ul><li>$0：当前行的所有内容。</li><li>$1, $2, $3,&mldr;：每行的各个字段，从第一个字段开始。</li><li>NR：当前行号。</li><li>NF：当前行的字段数。</li><li>FS：字段分隔符，默认为空格或制表符。</li><li>OFS：输出字段分隔符，默认为空格。</li><li>RS：行分隔符，默认为换行符。</li><li>ORS：输出行分隔符，默认为换行符。</li></ul><p>常用管道命令<code>sed</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sed <span class=o>[</span>-nefr<span class=o>]</span> <span class=o>[</span>action<span class=o>]</span>
</span></span><span class=line><span class=cl>选项与参数：
</span></span><span class=line><span class=cl>-n  ：使用安静<span class=o>(</span>silent<span class=o>)</span>模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。
</span></span><span class=line><span class=cl>      但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行<span class=o>(</span>或者动作<span class=o>)</span>才会被列出来。
</span></span><span class=line><span class=cl>-e  ：直接在指令列模式上进行 sed 的动作编辑；
</span></span><span class=line><span class=cl>-f  ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；
</span></span><span class=line><span class=cl>-r  ：sed 的动作支持的是延伸型正规表示法的语法。<span class=o>(</span>缺省是基础正规表示法语法<span class=o>)</span>
</span></span><span class=line><span class=cl>-i  ：直接修改读取的文件内容，而不是由屏幕输出。
</span></span><span class=line><span class=cl>动作说明：  <span class=o>[</span>n1<span class=o>[</span>,n2<span class=o>]]</span><span class=k>function</span>
</span></span><span class=line><span class=cl>n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作
</span></span><span class=line><span class=cl>         是需要在 <span class=m>10</span> 到 <span class=m>20</span> 行之间进行的，则『 10,20<span class=o>[</span>动作行为<span class=o>]</span> 』
</span></span><span class=line><span class=cl><span class=k>function</span> 有底下这些咚咚：
</span></span><span class=line><span class=cl>a   ：添加， a 的后面可以接字符串，而这些字符串会在新的一行出现<span class=o>(</span>目前的下一行<span class=o>)</span>～
</span></span><span class=line><span class=cl>c   ：取代， c 的后面可以接字符串，这些字符串可以取代 n1,n2 之间的行！
</span></span><span class=line><span class=cl>d   ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
</span></span><span class=line><span class=cl>i   ：插入， i 的后面可以接字符串，而这些字符串会在新的一行出现<span class=o>(</span>目前的上一行<span class=o>)</span>；
</span></span><span class=line><span class=cl>p   ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运作～
</span></span><span class=line><span class=cl>s   ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！
</span></span><span class=line><span class=cl>      例如 1,20s/old/new/g 就是啦！（类似vim命令行替换操作）
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>nl /etc/passwd <span class=p>|</span> sed <span class=s1>&#39;2,5d&#39;</span>
</span></span><span class=line><span class=cl><span class=c1># 将 /etc/passwd 的内容列出并且打印行号，同时，请将第 2~5 行删除！</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>nl /etc/passwd <span class=p>|</span> sed <span class=s1>&#39;2a drink tea&#39;</span>
</span></span><span class=line><span class=cl><span class=c1># 在第二行后(亦即是加在第三行)加上『drink tea』字样！</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>nl /etc/passwd <span class=p>|</span> sed <span class=s1>&#39;2i drink tea&#39;</span>
</span></span><span class=line><span class=cl><span class=c1># 在第二行前(亦即是加在第三行)加上『drink tea』字样！</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>nl /etc/passwd <span class=p>|</span> sed <span class=s1>&#39;2,5c No 2-5 number&#39;</span>
</span></span><span class=line><span class=cl><span class=c1># 将第2-5行的内容取代成为『No 2-5 number』</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>nl /etc/passwd <span class=p>|</span> sed -n <span class=s1>&#39;5,7p&#39;</span>
</span></span><span class=line><span class=cl><span class=c1># 列出 /etc/passwd 文件内的第 5-7 行</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>cat /etc/man_db.conf <span class=p>|</span> grep <span class=s1>&#39;MAN&#39;</span><span class=p>|</span> sed <span class=s1>&#39;s/#.*$//g&#39;</span>
</span></span><span class=line><span class=cl>删除掉注解之后的数据！
</span></span></code></pre></div><p><code>xargs + |</code>：<code>xargs</code>可以读入stdin的数据，并且以空格或换行字符作为分辨，将stdin的数据分隔成为arguments。</p><p><code>xargs</code>搭配<code>｜</code>更加美味😋：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>command1 <span class=p>|</span> xargs <span class=o>[</span>-ndI<span class=o>{}]</span> command2
</span></span><span class=line><span class=cl>选项与参数：
</span></span><span class=line><span class=cl>-n  ：后面接次数，每次command2指令运行时，要使用几个参数的意思。
</span></span><span class=line><span class=cl>-d  ：指定定界符，默认是空格或换行符。delimiter
</span></span><span class=line><span class=cl>-I<span class=o>{}</span>：指定替换字符串。每次读取一行数据并将<span class=o>{}</span>替换为该行数据。
</span></span><span class=line><span class=cl>cat hosts
</span></span><span class=line><span class=cl><span class=c1># delkon</span>
</span></span><span class=line><span class=cl><span class=c1># study</span>
</span></span><span class=line><span class=cl><span class=c1># flypig</span>
</span></span><span class=line><span class=cl><span class=c1># ikun</span>
</span></span><span class=line><span class=cl><span class=c1># daniel</span>
</span></span><span class=line><span class=cl>cat hosts <span class=p>|</span> xargs -I<span class=o>{}</span> <span class=nb>echo</span> root@<span class=o>{}</span>
</span></span><span class=line><span class=cl><span class=c1># root@delkon</span>
</span></span><span class=line><span class=cl><span class=c1># root@study</span>
</span></span><span class=line><span class=cl><span class=c1># root@flypig</span>
</span></span><span class=line><span class=cl><span class=c1># root@ikun</span>
</span></span><span class=line><span class=cl><span class=c1># root@daniel</span>
</span></span><span class=line><span class=cl>cat hosts <span class=p>|</span> xargs -n <span class=m>2</span> <span class=nb>echo</span>
</span></span><span class=line><span class=cl><span class=c1># delkon study</span>
</span></span><span class=line><span class=cl><span class=c1># flypig ikun</span>
</span></span><span class=line><span class=cl><span class=c1># daniel</span>
</span></span><span class=line><span class=cl>ls
</span></span><span class=line><span class=cl><span class=c1># dataloaders.py  lr_scheduler.py  torch_utils.py</span>
</span></span><span class=line><span class=cl>find . -name <span class=s1>&#39;*.py&#39;</span> <span class=p>|</span> xargs grep <span class=s1>&#39;matplotlib&#39;</span>
</span></span><span class=line><span class=cl><span class=c1># ./dataloaders.py:import matplotlib.pyplot as plt</span>
</span></span><span class=line><span class=cl><span class=c1># ./dataloaders.py:from matplotlib import rcParams</span>
</span></span></code></pre></div><h2 id=文件管理>文件管理<a hidden class=anchor aria-hidden=true href=#文件管理>#</a></h2><h3 id=ls--l展示文件属性><code>ls -l</code>展示文件属性<a hidden class=anchor aria-hidden=true href=#ls--l展示文件属性>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ls -l 
</span></span><span class=line><span class=cl><span class=c1># total 64</span>
</span></span><span class=line><span class=cl><span class=c1># lrwxrwxrwx   1 root root    7 Apr 22  2024 bin -&gt; usr/bin</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x   2 root root 4096 Apr 22  2024 boot</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x   5 root root  360 Mar 13 15:38 dev</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x   1 root root 4096 Mar 12 20:33 etc</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x   1 root root 4096 Jan 27 10:19 home</span>
</span></span><span class=line><span class=cl><span class=c1># lrwxrwxrwx   1 root root    7 Apr 22  2024 lib -&gt; usr/lib</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x   2 root root 4096 Jan 27 10:12 media</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x   2 root root 4096 Jan 27 10:12 mnt</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x   2 root root 4096 Jan 27 10:12 opt</span>
</span></span><span class=line><span class=cl><span class=c1># dr-xr-xr-x 213 root root    0 Mar 13 15:38 proc</span>
</span></span><span class=line><span class=cl><span class=c1># drwx------   1 root root 4096 Mar 13 16:25 root</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x   4 root root 4096 Jan 27 10:19 run</span>
</span></span><span class=line><span class=cl><span class=c1># lrwxrwxrwx   1 root root    8 Apr 22  2024 sbin -&gt; usr/sbin</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x   2 root root 4096 Jan 27 10:12 srv</span>
</span></span><span class=line><span class=cl><span class=c1># dr-xr-xr-x  11 root root    0 Mar 13 15:51 sys</span>
</span></span><span class=line><span class=cl><span class=c1># drwxrwxrwt   1 root root 4096 Mar 12 17:30 tmp</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x   1 root root 4096 Jan 27 10:12 usr</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x   1 root root 4096 Jan 27 10:19 var</span>
</span></span></code></pre></div><p>第一列总共10位</p><ul><li>第一位表示文件类型，可以有以下几种字母表示：<ul><li><code>-</code>：普通文件</li><li><code>d</code>：目录</li><li><code>l</code>：符号连接</li><li><code>b</code>：块设备文件</li><li><code>c</code>：字符设备文件</li><li><code>s</code>：套接字</li><li><code>p</code>：命名管道</li></ul></li><li>剩下9位分为3组，每组3位分别有以下权限<code>r</code>（可读）<code>w</code>（可写）<code>x</code>（可执行）<ul><li>2-4位：文件属主（owner）的权限</li><li>5-7位：同组用户（group）的权限</li><li>8-10位：其他用户（others）的权限</li></ul></li></ul><p>第二列表示硬链接数，硬链接是指向同一个文件的多个文件名。对于目录，这个数字表示目录下的子目录数量加 2（当前目录 . 和父目录 ..）。</p><p>第三列和第四列分别表示文件属主和文件属组。</p><p>第五列表示文件大小，以字节为单位。如果文件是符号链接，大小为链接目标的路径长度（如 bin -> usr/bin 中，大小为 7 是因为 usr/bin 有 7 个字符）。如果是目录，则一般固定为 4096 字节。</p><p>第六列第七列第八列表示最后修改时间。</p><p>第九列表示文件名，如果是符号链接（如 bin -> usr/bin），则后面会显示链接的目标。</p><h3 id=ln进行符号链接和硬链接><code>ln</code>进行符号链接和硬链接<a hidden class=anchor aria-hidden=true href=#ln进行符号链接和硬链接>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ln <span class=o>[</span>-sf<span class=o>]</span> src dst
</span></span><span class=line><span class=cl>选项与参数：
</span></span><span class=line><span class=cl>-s  ：创建符号链接。
</span></span><span class=line><span class=cl>-f  ：强制创建链接文件，覆盖已经存在的目标文件。
</span></span><span class=line><span class=cl>ls
</span></span><span class=line><span class=cl><span class=c1># Python  hosts</span>
</span></span><span class=line><span class=cl>ln hosts hardlink_hosts
</span></span><span class=line><span class=cl>ls
</span></span><span class=line><span class=cl><span class=c1># Python  hardlink_hosts  hosts</span>
</span></span><span class=line><span class=cl>ln -s hosts symboliclink_hosts
</span></span><span class=line><span class=cl>ls 
</span></span><span class=line><span class=cl><span class=c1># Python  hardlink_hosts  hosts  symboliclink_hosts</span>
</span></span><span class=line><span class=cl>ls -l 
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x 2 root root 4096 Mar 13 16:25 Python</span>
</span></span><span class=line><span class=cl><span class=c1># -rw-r--r-- 2 root root   32 Mar 13 16:09 hardlink_hosts</span>
</span></span><span class=line><span class=cl><span class=c1># -rw-r--r-- 2 root root   32 Mar 13 16:09 hosts</span>
</span></span><span class=line><span class=cl><span class=c1># lrwxrwxrwx 1 root root    5 Mar 13 17:25 symboliclink_hosts -&gt; hosts</span>
</span></span><span class=line><span class=cl>cat hosts
</span></span><span class=line><span class=cl>cat hardlink_hosts
</span></span><span class=line><span class=cl>cat symboliclink_hosts
</span></span><span class=line><span class=cl><span class=c1># delkon</span>
</span></span><span class=line><span class=cl><span class=c1># study</span>
</span></span><span class=line><span class=cl><span class=c1># flypig</span>
</span></span><span class=line><span class=cl><span class=c1># ikun</span>
</span></span><span class=line><span class=cl><span class=c1># daniel</span>
</span></span></code></pre></div><table><thead><tr><th><strong>特性</strong></th><th><strong>硬链接（Hard Link）</strong></th><th><strong>符号链接（Symbolic Link）</strong></th></tr></thead><tbody><tr><td>指向</td><td>指向文件的物理数据块</td><td>指向文件的路径</td></tr><tr><td>文件大小</td><td>与原文件相同</td><td>符号链接本身只占用少量空间（保存路径）</td></tr><tr><td>文件系统限制</td><td>只能在同一文件系统上创建</td><td>可以跨文件系统创建</td></tr><tr><td>删除效果</td><td>删除硬链接不会删除文件数据，除非所有硬链接被删除</td><td>删除符号链接不会影响原文件</td></tr><tr><td>适用场景</td><td>文件备份，防止意外删除</td><td>快捷访问其他文件、跨目录、文件系统使用</td></tr></tbody></table><h3 id=硬盘>硬盘<a hidden class=anchor aria-hidden=true href=#硬盘>#</a></h3><p>硬盘的使用：硬盘分区<code>-></code>硬盘格式化（format)<code>-></code>文件系统的挂载</p><h4 id=硬盘分区>硬盘分区<a hidden class=anchor aria-hidden=true href=#硬盘分区>#</a></h4><ul><li><code>/dev/sd[a-p][1-128]</code>：为分区后的实体硬盘分配的硬盘文件名；</li><li><code>/dev/vd[a-d][1-128]</code>：为分区后的虚拟硬盘分配的硬盘文件名。</li></ul><p>本系统下的所有磁盘与磁盘内的分割信息使用<code>lsblk</code>(list block device)查看</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>lsblk <span class=o>[</span>-dfimpt<span class=o>]</span> <span class=o>[</span>device<span class=o>]</span>
</span></span><span class=line><span class=cl>选项与参数：
</span></span><span class=line><span class=cl>-d  ：仅列出磁盘本身，并不会列出该磁盘的分割数据
</span></span><span class=line><span class=cl>-f  ：同时列出该磁盘内的文件系统名称
</span></span><span class=line><span class=cl>-i  ：使用 ASCII 的线段输出，不要使用复杂的编码 <span class=o>(</span>再某些环境下很有用<span class=o>)</span>
</span></span><span class=line><span class=cl>-m  ：同时输出该设备在 /dev 底下的权限数据 <span class=o>(</span>rwx 的数据<span class=o>)</span>
</span></span><span class=line><span class=cl>-p  ：列出该设备的完整文件名！而不是仅列出最后的名字而已。
</span></span><span class=line><span class=cl>-t  ：列出该磁盘设备的详细数据，包括磁盘队列机制、预读写的数据量大小等
</span></span><span class=line><span class=cl>lsblk
</span></span><span class=line><span class=cl><span class=c1># NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span>
</span></span><span class=line><span class=cl><span class=c1># nbd0    43:0    0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd1    43:32   0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd2    43:64   0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd3    43:96   0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd4    43:128  0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd5    43:160  0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd6    43:192  0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd7    43:224  0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># vda    254:0    0  59.6G  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># `-vda1 254:1    0  59.6G  0 part /etc/hosts</span>
</span></span><span class=line><span class=cl><span class=c1>#                                  /etc/hostname</span>
</span></span><span class=line><span class=cl><span class=c1>#                                  /etc/resolv.conf</span>
</span></span><span class=line><span class=cl><span class=c1># vdb    254:16   0 535.2M  1 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd8    43:256  0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd9    43:288  0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd10   43:320  0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd11   43:352  0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd12   43:384  0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd13   43:416  0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd14   43:448  0     0B  0 disk</span>
</span></span><span class=line><span class=cl><span class=c1># nbd15   43:480  0     0B  0 disk</span>
</span></span></code></pre></div><ul><li>NAME：就是设备的文件名！会省略 /dev 等前导目录！</li><li>MAJ:MIN：其实核心认识的设备都是透过这两个代码来熟悉的！分别是主要：次要设备代码！</li><li>RM：是否为可卸载设备 (removable device)，如光盘、USB 磁盘等等</li><li>SIZE：当然就是容量啰！</li><li>RO：是否为唯读设备的意思</li><li>TYPE：是磁盘 (disk)、分区 (partition) 还是唯读内存 (rom) 等输出</li><li>MOUTPOINT：就是挂载点！</li></ul><h4 id=硬盘格式化>硬盘格式化<a hidden class=anchor aria-hidden=true href=#硬盘格式化>#</a></h4><p>分割完毕后自然就是要进行文件系统的格式化，我们使用<code>mkfs</code>(make filesystem)来进行分区后硬盘的格式化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkfs<span class=o>[</span>tab<span class=o>][</span>tab<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=c1># mkfs         mkfs.cramfs  mkfs.ext3    mkfs.minix</span>
</span></span><span class=line><span class=cl><span class=c1># mkfs.bfs     mkfs.ext2    mkfs.ext4</span>
</span></span></code></pre></div><h4 id=文件系统挂载>文件系统挂载<a hidden class=anchor aria-hidden=true href=#文件系统挂载>#</a></h4><p>我们首先要明确，挂载点是目录，这个目录是进入硬盘分区（文件系统）的入口。同时挂载之前我们还应该确定一些事：</p><ul><li>单一文件系统不应该被重复挂载在不同的挂载点(目录)中；</li><li>单一目录不应该重复挂载多个文件系统；</li><li>要作为挂载点的目录，理论上应该都是空目录才是。</li></ul><p>挂载使用的命令是<code>mount</code>，具体如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mount -a
</span></span><span class=line><span class=cl>mount <span class=o>[</span>-l<span class=o>]</span>
</span></span><span class=line><span class=cl>mount <span class=o>[</span>-t 文件系统<span class=o>]</span> <span class=nv>LABEL</span><span class=o>=</span><span class=s1>&#39;&#39;</span>  挂载点
</span></span><span class=line><span class=cl>mount <span class=o>[</span>-t 文件系统<span class=o>]</span> <span class=nv>UUID</span><span class=o>=</span><span class=s1>&#39;&#39;</span>   挂载点  <span class=c1># 鸟哥近期建议用这种方式喔！</span>
</span></span><span class=line><span class=cl>mount <span class=o>[</span>-t 文件系统<span class=o>]</span> 设备文件名  挂载点
</span></span><span class=line><span class=cl>选项与参数：
</span></span><span class=line><span class=cl>-a  ：依照设置档 <span class=o>[</span>/etc/fstab<span class=o>](</span>https://muicoder.github.io/linux_basic/0230filesystem.html#fstab<span class=o>)</span>的数据将所有未挂载的磁盘都挂载上来
</span></span><span class=line><span class=cl>-l  ：单纯的输入 mount 会显示目前挂载的信息。加上 -l 可增列 Label 名称！
</span></span><span class=line><span class=cl>-t  ：可以加上文件系统种类来指定欲挂载的类型。常见的 Linux 支持类型有：xfs, ext3, ext4, reiserfs, vfat, iso9660<span class=o>(</span>光盘格式<span class=o>)</span>, nfs, cifs, smbfs <span class=o>(</span>后三种为网络文件系统类型<span class=o>)</span>
</span></span></code></pre></div><h4 id=设备文件的卸载>设备文件的卸载<a hidden class=anchor aria-hidden=true href=#设备文件的卸载>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>umount <span class=o>[</span>-fn<span class=o>]</span> 设备文件名或挂载点
</span></span><span class=line><span class=cl>选项与参数：
</span></span><span class=line><span class=cl>-f  ：强制卸载！可用在类似网络文件系统 <span class=o>(</span>NFS<span class=o>)</span> 无法读取到的情况下；
</span></span><span class=line><span class=cl>-l  ：立刻卸载文件系统，比 -f 还强！
</span></span><span class=line><span class=cl>-n  ：不更新 /etc/mtab 情况下卸载。
</span></span></code></pre></div><h4 id=硬盘状态>硬盘状态<a hidden class=anchor aria-hidden=true href=#硬盘状态>#</a></h4><p>df（<strong>disk free</strong>）用于显示<strong>磁盘的整体使用情况</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>df <span class=o>[</span>-akmhHTi<span class=o>]</span> <span class=o>[</span>目录或文件名<span class=o>]</span>
</span></span><span class=line><span class=cl>选项与参数：
</span></span><span class=line><span class=cl>-a  ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；
</span></span><span class=line><span class=cl>-k  ：以 KBytes 的容量显示各文件系统；
</span></span><span class=line><span class=cl>-m  ：以 MBytes 的容量显示各文件系统；
</span></span><span class=line><span class=cl>-h  ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；
</span></span><span class=line><span class=cl>-H  ：以 <span class=nv>M</span><span class=o>=</span>1000K 取代 <span class=nv>M</span><span class=o>=</span>1024K 的进位方式；
</span></span><span class=line><span class=cl>-T  ：连同该 partition 的 filesystem 名称 <span class=o>(</span>例如 xfs<span class=o>)</span> 也列出；
</span></span><span class=line><span class=cl>-i  ：不用磁盘容量，而以 inode 的数量来显示
</span></span><span class=line><span class=cl>df -h
</span></span><span class=line><span class=cl><span class=c1># Filesystem      Size  Used Avail Use% Mounted on</span>
</span></span><span class=line><span class=cl><span class=c1># overlay          59G  1.3G   55G   3% /</span>
</span></span><span class=line><span class=cl><span class=c1># tmpfs            64M     0   64M   0% /dev</span>
</span></span><span class=line><span class=cl><span class=c1># shm              64M     0   64M   0% /dev/shm</span>
</span></span><span class=line><span class=cl><span class=c1># /dev/vda1        59G  1.3G   55G   3% /etc/hosts</span>
</span></span><span class=line><span class=cl><span class=c1># tmpfs           2.0G     0  2.0G   0% /proc/scsi</span>
</span></span><span class=line><span class=cl><span class=c1># tmpfs           2.0G     0  2.0G   0% /sys/firmware</span>
</span></span></code></pre></div><p>du（<strong>disk usage</strong>）用于<strong>查看文件和目录的磁盘使用情况</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>du <span class=o>[</span>-ahskm<span class=o>]</span> 文件或目录名称
</span></span><span class=line><span class=cl>-a  ：列出所有的文件与目录容量，因为缺省仅统计目录底下的文件量而已。
</span></span><span class=line><span class=cl>-h  ：以人们较易读的容量格式 <span class=o>(</span>G/M<span class=o>)</span> 显示；
</span></span><span class=line><span class=cl>-s  ：列出总量而已，而不列出每个各别的目录占用容量；
</span></span><span class=line><span class=cl>-S  ：不包括子目录下的总计，与 -s 有点差别。
</span></span><span class=line><span class=cl>-k  ：以 KBytes 列出容量显示；
</span></span><span class=line><span class=cl>-m  ：以 MBytes 列出容量显示；
</span></span></code></pre></div><h3 id=linux文件>Linux文件<a hidden class=anchor aria-hidden=true href=#linux文件>#</a></h3><h4 id=文件属性和权限的更改>文件属性和权限的更改<a hidden class=anchor aria-hidden=true href=#文件属性和权限的更改>#</a></h4><p>• <strong>chown</strong> 用于更改文件或目录的所有者和组。要注意的是， 用户必须是已经存在系统中的帐号，也就是在<code>/etc/passwd</code> 这个文件中有纪录的用户名才能改变。可更改的组名也记录在<code>/etc/group</code>中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>chown <span class=o>[</span>-R<span class=o>]</span> 用户 文件或目录
</span></span><span class=line><span class=cl>chown <span class=o>[</span>-R<span class=o>]</span> 用户:组 文件或目录
</span></span><span class=line><span class=cl>选项与参数：
</span></span><span class=line><span class=cl>-R : 进行递归<span class=o>(</span>recursive<span class=o>)</span>的持续变更，亦即连同次目录下的所有文件都变更
</span></span><span class=line><span class=cl>ll 
</span></span><span class=line><span class=cl><span class=c1># total 32</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x 2 ubuntu ubuntu 4096 Mar 14 11:24 ./</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-x--- 1 ubuntu ubuntu 4096 Mar 14 11:24 ../</span>
</span></span><span class=line><span class=cl><span class=c1># -rw-r--r-- 1 ubuntu ubuntu 8733 Mar 13 16:25 dataloaders.py</span>
</span></span><span class=line><span class=cl><span class=c1># -rw-r--r-- 1 ubuntu ubuntu 4231 Mar 13 16:24 lr_scheduler.py</span>
</span></span><span class=line><span class=cl><span class=c1># -rw-r--r-- 1 ubuntu ubuntu 4043 Mar 13 16:24 torch_utils.py</span>
</span></span><span class=line><span class=cl>chown -R root:root ./
</span></span><span class=line><span class=cl>ll 
</span></span><span class=line><span class=cl><span class=c1># total 32</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x 2 root   root   4096 Mar 14 11:27 ./</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-x--- 1 ubuntu ubuntu 4096 Mar 14 11:24 ../</span>
</span></span><span class=line><span class=cl><span class=c1># -rw-r--r-- 1 root   root   8748 Mar 14 11:27 dataloaders.py</span>
</span></span><span class=line><span class=cl><span class=c1># -rw-r--r-- 1 root   root   4231 Mar 13 16:24 lr_scheduler.py</span>
</span></span><span class=line><span class=cl><span class=c1># -rw-r--r-- 1 root   root   4043 Mar 13 16:24 torch_utils.py</span>
</span></span></code></pre></div><p>• <strong>chmod</strong> 用于更改文件或目录的权限，控制读、写、执行权限。</p><ol><li>数字</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>chmod <span class=o>[</span>-R<span class=o>]</span> xyz 文件或目录
</span></span><span class=line><span class=cl>选项与参数：
</span></span><span class=line><span class=cl>xyz : 就是刚刚提到的数字类型的权限属性，为 r<span class=o>(</span>4<span class=o>)</span>w<span class=o>(</span>2<span class=o>)</span>x<span class=o>(</span>1<span class=o>)</span> 属性数值的相加。
</span></span><span class=line><span class=cl>-R : 进行递归<span class=o>(</span>recursive<span class=o>)</span>的持续变更，亦即连同次目录下的所有文件都会变更
</span></span><span class=line><span class=cl>ll ./dataloader.py
</span></span><span class=line><span class=cl><span class=c1># -rw-r--r-- 1 root   root   8748 Mar 14 11:27 dataloaders.py</span>
</span></span><span class=line><span class=cl>chmod a+w ./dataloader.py
</span></span><span class=line><span class=cl>ll ./dataloader.py
</span></span><span class=line><span class=cl><span class=c1># -rw-rw-rw- 1 root   root   8748 Mar 14 11:27 dataloaders.py</span>
</span></span><span class=line><span class=cl>chmod <span class=nv>u</span><span class=o>=</span>rw.go<span class=o>=</span>r ./dataloader.py
</span></span><span class=line><span class=cl>ll ./dataloader.py
</span></span><span class=line><span class=cl><span class=c1># -rw-r--r-- 1 root root 8748 Mar 14 11:27 ./dataloaders.py</span>
</span></span></code></pre></div><ol start=2><li>符号</li></ol><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>chmod</td><td>u (user)<br>g (group)<br>o (others)<br>a (all)</td><td>+(加入)<br>-(除去)<br>=(设置)</td><td>r<br>w<br>x</td><td>文件或目录</td></tr></tbody></table><h4 id=文件搜索>文件搜索<a hidden class=anchor aria-hidden=true href=#文件搜索>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>find <span class=o>[</span>PATH<span class=o>]</span> <span class=o>[</span>option<span class=o>]</span> <span class=o>[</span>action<span class=o>]</span>
</span></span><span class=line><span class=cl>选项与参数：
</span></span><span class=line><span class=cl>与文件权限及名称有关的参数：
</span></span><span class=line><span class=cl>-name filename：搜索文件名称为 filename 的文件；
</span></span><span class=line><span class=cl>-size <span class=o>[</span>+-<span class=o>]</span>SIZE：搜索比 SIZE 还要大<span class=o>(</span>+<span class=o>)</span>或小<span class=o>(</span>-<span class=o>)</span>的文件。这个 SIZE 的规格有：c: 代表 byte， k: 代表 1024bytes。所以，要找比 50KB还要大的文件，就是『 -size +50k 』
</span></span><span class=line><span class=cl>-type TYPE    ：搜索文件的类型为 TYPE 的，类型主要有：一般正规文件 <span class=o>(</span>f<span class=o>)</span>, 设备文件 <span class=o>(</span>b, c<span class=o>)</span>, 目录 <span class=o>(</span>d<span class=o>)</span>, 链接档 <span class=o>(</span>l<span class=o>)</span>, socket <span class=o>(</span>s<span class=o>)</span>, 及 FIFO <span class=o>(</span>p<span class=o>)</span> 等属性。
</span></span><span class=line><span class=cl>ll /Python
</span></span><span class=line><span class=cl><span class=c1># total 32</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-xr-x 2 root   root   4096 Mar 14 11:40 ./</span>
</span></span><span class=line><span class=cl><span class=c1># drwxr-x--- 1 ubuntu ubuntu 4096 Mar 14 12:50 ../</span>
</span></span><span class=line><span class=cl><span class=c1># -rw-r--r-- 1 root   root   8748 Mar 14 11:27 dataloaders.py</span>
</span></span><span class=line><span class=cl><span class=c1># -rw-r--r-- 1 root   root   4231 Mar 13 16:24 lr_scheduler.py</span>
</span></span><span class=line><span class=cl><span class=c1># -rw-r--r-- 1 root   root   4043 Mar 13 16:24 torch_utils.py</span>
</span></span><span class=line><span class=cl>find Python/ -name <span class=s1>&#39;*.py&#39;</span>
</span></span><span class=line><span class=cl><span class=c1># Python/torch_utils.py</span>
</span></span><span class=line><span class=cl><span class=c1># Python/lr_scheduler.py</span>
</span></span><span class=line><span class=cl><span class=c1># Python/dataloaders.py</span>
</span></span><span class=line><span class=cl>find Python/ -size -20k
</span></span><span class=line><span class=cl><span class=c1># Python/</span>
</span></span><span class=line><span class=cl><span class=c1># Python/torch_utils.py</span>
</span></span><span class=line><span class=cl><span class=c1># Python/lr_scheduler.py</span>
</span></span><span class=line><span class=cl><span class=c1># Python/dataloaders.py</span>
</span></span><span class=line><span class=cl>find Python/ -type f
</span></span><span class=line><span class=cl><span class=c1># Python/torch_utils.py</span>
</span></span><span class=line><span class=cl><span class=c1># Python/lr_scheduler.py</span>
</span></span><span class=line><span class=cl><span class=c1># Python/dataloaders.py</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://fordelkon.github.io/tags/shell/>Shell</a></li><li><a href=https://fordelkon.github.io/tags/linux/>Linux</a></li><li><a href=https://fordelkon.github.io/tags/docker/>Docker</a></li></ul><nav class=paginav><a class=prev href=https://fordelkon.github.io/posts/docker_intro/><span class=title>« Prev</span><br><span>使用Docker的艺术</span>
</a><a class=next href=https://fordelkon.github.io/posts/cmd_intro_1/><span class=title>Next »</span><br><span>使用命令行的艺术1</span></a></nav></footer><div class=giscus_comments><script src=https://giscus.app/client.js data-repo=jesse-wei/jessewei.dev-PaperMod data-repo-id=R_kgDOJhJgPg data-category=Comments data-category-id=DIC_kwDOJhJgPs4CWei3 data-mapping=pathname data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><script async>document.querySelector("div.giscus_comments > script").setAttribute("data-theme",localStorage.getItem("pref-theme")?localStorage.getItem("pref-theme"):window.matchMedia("(prefers-color-scheme: dark)").matches?"transparent_dark":"light"),document.querySelector("#theme-toggle").addEventListener("click",()=>{let e=document.querySelector("iframe.giscus-frame");e&&e.contentWindow.postMessage({giscus:{setConfig:{theme:localStorage.getItem("pref-theme")?localStorage.getItem("pref-theme")==="dark"?"light":"transparent_dark":document.body.className.includes("dark")?"light":"transparent_dark"}}},"https://giscus.app")})</script></article></main><footer class=footer style=padding-top:18px;padding-bottom:18px><div class=social-icons style=padding-bottom:0><a style=border-bottom:none href=https://github.com/fordelkon rel=me title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a style=border-bottom:none href=https://x.com/fordelkon rel=me title=Twitter><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg>
</a><a style=border-bottom:none href=mailto:dlkong201893@gmail.com rel=me title=Email><svg viewBox="0 0 24 21" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div><span>&copy; 2025 <a href=https://fordelkon.github.io/>DL Kong</a></span>
<span>•
Powered by
<a href=https://gohugo.io/>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/>PaperMod</a>
</span><span>•
<a href=/privacy>Privacy Policy</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let b=document.querySelector("#menu-trigger"),m=document.querySelector(".menu");b.addEventListener("click",function(){m.classList.toggle("hidden")}),document.body.addEventListener("click",function(e){b.contains(e.target)||m.classList.add("hidden")})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>